import { Runnable, RunnableConfig, RunnableFunc } from "@langchain/core/runnables";
import { IterableReadableStream } from "@langchain/core/utils/stream";
import { BaseCheckpointSaver, CheckpointListOptions } from "@langchain/langgraph-checkpoint";
import { BaseChannel } from "../channels/base.js";
import { PregelNode } from "./read.js";
import { ChannelWrite } from "./write.js";
import { All, PregelInterface, PregelParams, StateSnapshot, StreamMode } from "./types.js";
import { StrRecord } from "./algo.js";
import { RetryPolicy } from "./utils.js";
type WriteValue = Runnable | RunnableFunc<unknown, unknown> | unknown;
export declare class Channel {
    static subscribeTo(channels: string, options?: {
        key?: string;
        tags?: string[];
    }): PregelNode;
    static subscribeTo(channels: string[], options?: {
        tags?: string[];
    }): PregelNode;
    static writeTo(channels: string[], kwargs?: Record<string, WriteValue>): ChannelWrite;
}
/**
 * Config for executing the graph.
 */
export interface PregelOptions<Nn extends StrRecord<string, PregelNode>, Cc extends StrRecord<string, BaseChannel>> extends RunnableConfig {
    /** The stream mode for the graph run. Default is ["values"]. */
    streamMode?: StreamMode | StreamMode[];
    inputKeys?: keyof Cc | Array<keyof Cc>;
    /** The output keys to retrieve from the graph run. */
    outputKeys?: keyof Cc | Array<keyof Cc>;
    /** The nodes to interrupt the graph run before. */
    interruptBefore?: All | Array<keyof Nn>;
    /** The nodes to interrupt the graph run after. */
    interruptAfter?: All | Array<keyof Nn>;
    /** Enable debug mode for the graph run. */
    debug?: boolean;
}
export type PregelInputType = any;
export type PregelOutputType = any;
export declare class Pregel<Nn extends StrRecord<string, PregelNode>, Cc extends StrRecord<string, BaseChannel>> extends Runnable<PregelInputType, PregelOutputType, PregelOptions<Nn, Cc>> implements PregelInterface<Nn, Cc> {
    static lc_name(): string;
    lc_namespace: string[];
    nodes: Nn;
    channels: Cc;
    inputChannels: keyof Cc | Array<keyof Cc>;
    outputChannels: keyof Cc | Array<keyof Cc>;
    autoValidate: boolean;
    streamMode: StreamMode[];
    streamChannels?: keyof Cc | Array<keyof Cc>;
    interruptAfter?: Array<keyof Nn> | All;
    interruptBefore?: Array<keyof Nn> | All;
    stepTimeout?: number;
    debug: boolean;
    checkpointer?: BaseCheckpointSaver;
    retryPolicy?: RetryPolicy;
    constructor(fields: PregelParams<Nn, Cc>);
    validate(): this;
    get streamChannelsList(): Array<keyof Cc>;
    get streamChannelsAsIs(): keyof Cc | Array<keyof Cc>;
    /**
     * Get the current state of the graph.
     */
    getState(config: RunnableConfig): Promise<StateSnapshot>;
    /**
     * Get the history of the state of the graph.
     */
    getStateHistory(config: RunnableConfig, options?: CheckpointListOptions): AsyncIterableIterator<StateSnapshot>;
    /**
     * Update the state of the graph with the given values, as if they came from
     * node `as_node`. If `as_node` is not provided, it will be set to the last node
     * that updated the state, if not ambiguous.
     */
    updateState(config: RunnableConfig, values: Record<string, unknown> | unknown, asNode?: keyof Nn): Promise<RunnableConfig>;
    _defaults(config: PregelOptions<Nn, Cc>): [
        boolean,
        StreamMode[],
        // stream mode
        string | string[],
        // input keys
        string | string[],
        RunnableConfig,
        // config without pregel keys
        All | string[],
        // interrupt before
        All | string[],
        // interrupt after
        BaseCheckpointSaver | undefined
    ];
    /**
     * Stream graph steps for a single input.
     * @param input The input to the graph.
     * @param options The configuration to use for the run.
     * @param options.streamMode The mode to stream output. Defaults to value set on initialization.
     *   Options are "values", "updates", and "debug". Default is "values".
     *     values: Emit the current values of the state for each step.
     *     updates: Emit only the updates to the state for each step.
     *         Output is a dict with the node name as key and the updated values as value.
     *     debug: Emit debug events for each step.
     * @param options.outputKeys The keys to stream. Defaults to all non-context channels.
     * @param options.interruptBefore Nodes to interrupt before.
     * @param options.interruptAfter Nodes to interrupt after.
     * @param options.debug Whether to print debug information during execution.
     */
    stream(input: PregelInputType, options?: Partial<PregelOptions<Nn, Cc>>): Promise<IterableReadableStream<PregelOutputType>>;
    _streamIterator(input: PregelInputType, options?: Partial<PregelOptions<Nn, Cc>>): AsyncGenerator<PregelOutputType>;
    /**
     * Run the graph with a single input and config.
     * @param input The input to the graph.
     * @param options The configuration to use for the run.
     * @param options.streamMode The mode to stream output. Defaults to value set on initialization.
     *   Options are "values", "updates", and "debug". Default is "values".
     *     values: Emit the current values of the state for each step.
     *     updates: Emit only the updates to the state for each step.
     *         Output is a dict with the node name as key and the updated values as value.
     *     debug: Emit debug events for each step.
     * @param options.outputKeys The keys to stream. Defaults to all non-context channels.
     * @param options.interruptBefore Nodes to interrupt before.
     * @param options.interruptAfter Nodes to interrupt after.
     * @param options.debug Whether to print debug information during execution.
     */
    invoke(input: PregelInputType, options?: Partial<PregelOptions<Nn, Cc>>): Promise<PregelOutputType>;
}
export {};
