"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pregel = exports.Channel = void 0;
/* eslint-disable no-param-reassign */
const runnables_1 = require("@langchain/core/runnables");
const langgraph_checkpoint_1 = require("@langchain/langgraph-checkpoint");
const base_js_1 = require("../channels/base.cjs");
const read_js_1 = require("./read.cjs");
const validate_js_1 = require("./validate.cjs");
const io_js_1 = require("./io.cjs");
const debug_js_1 = require("./debug.cjs");
const write_js_1 = require("./write.cjs");
const constants_js_1 = require("../constants.cjs");
const errors_js_1 = require("../errors.cjs");
const algo_js_1 = require("./algo.cjs");
const utils_js_1 = require("./utils.cjs");
const loop_js_1 = require("./loop.cjs");
const retry_js_1 = require("./retry.cjs");
function isString(value) {
    return typeof value === "string";
}
class Channel {
    static subscribeTo(channels, options) {
        const { key, tags } = options ?? {};
        if (Array.isArray(channels) && key !== undefined) {
            throw new Error("Can't specify a key when subscribing to multiple channels");
        }
        let channelMappingOrArray;
        if (isString(channels)) {
            if (key) {
                channelMappingOrArray = { [key]: channels };
            }
            else {
                channelMappingOrArray = [channels];
            }
        }
        else {
            channelMappingOrArray = Object.fromEntries(channels.map((chan) => [chan, chan]));
        }
        const triggers = Array.isArray(channels) ? channels : [channels];
        return new read_js_1.PregelNode({
            channels: channelMappingOrArray,
            triggers,
            tags,
        });
    }
    static writeTo(channels, kwargs) {
        const channelWriteEntries = [];
        for (const channel of channels) {
            channelWriteEntries.push({
                channel,
                value: write_js_1.PASSTHROUGH,
                skipNone: false,
            });
        }
        for (const [key, value] of Object.entries(kwargs ?? {})) {
            if (runnables_1.Runnable.isRunnable(value) || typeof value === "function") {
                channelWriteEntries.push({
                    channel: key,
                    value: write_js_1.PASSTHROUGH,
                    skipNone: true,
                    mapper: (0, runnables_1._coerceToRunnable)(value),
                });
            }
            else {
                channelWriteEntries.push({
                    channel: key,
                    value,
                    skipNone: false,
                });
            }
        }
        return new write_js_1.ChannelWrite(channelWriteEntries);
    }
}
exports.Channel = Channel;
class Pregel extends runnables_1.Runnable {
    static lc_name() {
        return "LangGraph";
    }
    constructor(fields) {
        super(fields);
        // Because Pregel extends `Runnable`.
        Object.defineProperty(this, "lc_namespace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ["langgraph", "pregel"]
        });
        Object.defineProperty(this, "nodes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "channels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "inputChannels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "outputChannels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "autoValidate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "streamMode", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ["values"]
        });
        Object.defineProperty(this, "streamChannels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "interruptAfter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "interruptBefore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "stepTimeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "debug", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "checkpointer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "retryPolicy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        let { streamMode } = fields;
        if (streamMode != null && !Array.isArray(streamMode)) {
            streamMode = [streamMode];
        }
        this.nodes = fields.nodes;
        this.channels = fields.channels;
        this.autoValidate = fields.autoValidate ?? this.autoValidate;
        this.streamMode = streamMode ?? this.streamMode;
        this.inputChannels = fields.inputChannels;
        this.outputChannels = fields.outputChannels;
        this.streamChannels = fields.streamChannels ?? this.streamChannels;
        this.interruptAfter = fields.interruptAfter;
        this.interruptBefore = fields.interruptBefore;
        this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;
        this.debug = fields.debug ?? this.debug;
        this.checkpointer = fields.checkpointer;
        this.retryPolicy = fields.retryPolicy;
        if (this.autoValidate) {
            this.validate();
        }
    }
    validate() {
        (0, validate_js_1.validateGraph)({
            nodes: this.nodes,
            channels: this.channels,
            outputChannels: this.outputChannels,
            inputChannels: this.inputChannels,
            streamChannels: this.streamChannels,
            interruptAfterNodes: this.interruptAfter,
            interruptBeforeNodes: this.interruptBefore,
        });
        return this;
    }
    get streamChannelsList() {
        if (Array.isArray(this.streamChannels)) {
            return this.streamChannels;
        }
        else if (this.streamChannels) {
            return [this.streamChannels];
        }
        else {
            return Object.keys(this.channels);
        }
    }
    get streamChannelsAsIs() {
        if (this.streamChannels) {
            return this.streamChannels;
        }
        else {
            return Object.keys(this.channels);
        }
    }
    /**
     * Get the current state of the graph.
     */
    async getState(config) {
        if (!this.checkpointer) {
            throw new errors_js_1.GraphValueError("No checkpointer set");
        }
        const saved = await this.checkpointer.getTuple(config);
        const checkpoint = saved ? saved.checkpoint : (0, langgraph_checkpoint_1.emptyCheckpoint)();
        const channels = (0, base_js_1.emptyChannels)(this.channels, checkpoint);
        const nextTasks = (0, algo_js_1._prepareNextTasks)(checkpoint, this.nodes, channels, saved !== undefined ? saved.config : config, false, { step: saved ? (saved.metadata?.step ?? -1) + 1 : -1 });
        return {
            values: (0, io_js_1.readChannels)(channels, this.streamChannelsAsIs),
            next: nextTasks.map((task) => task.name),
            tasks: (0, debug_js_1.tasksWithWrites)(nextTasks, saved?.pendingWrites ?? []),
            metadata: saved?.metadata,
            config: saved ? saved.config : config,
            createdAt: saved?.checkpoint.ts,
            parentConfig: saved?.parentConfig,
        };
    }
    /**
     * Get the history of the state of the graph.
     */
    async *getStateHistory(config, options) {
        if (!this.checkpointer) {
            throw new errors_js_1.GraphValueError("No checkpointer set");
        }
        for await (const saved of this.checkpointer.list(config, options)) {
            const channels = (0, base_js_1.emptyChannels)(this.channels, saved.checkpoint);
            const nextTasks = (0, algo_js_1._prepareNextTasks)(saved.checkpoint, this.nodes, channels, saved.config, false, { step: -1 });
            yield {
                values: (0, io_js_1.readChannels)(channels, this.streamChannelsAsIs),
                next: nextTasks.map((task) => task.name),
                tasks: (0, debug_js_1.tasksWithWrites)(nextTasks, saved.pendingWrites ?? []),
                metadata: saved.metadata,
                config: saved.config,
                createdAt: saved.checkpoint.ts,
                parentConfig: saved.parentConfig,
            };
        }
    }
    /**
     * Update the state of the graph with the given values, as if they came from
     * node `as_node`. If `as_node` is not provided, it will be set to the last node
     * that updated the state, if not ambiguous.
     */
    async updateState(config, values, asNode) {
        if (!this.checkpointer) {
            throw new errors_js_1.GraphValueError("No checkpointer set");
        }
        // Get the latest checkpoint
        const saved = await this.checkpointer.getTuple(config);
        const checkpoint = saved
            ? (0, langgraph_checkpoint_1.copyCheckpoint)(saved.checkpoint)
            : (0, langgraph_checkpoint_1.emptyCheckpoint)();
        const checkpointPreviousVersions = saved?.checkpoint.channel_versions ?? {};
        const step = saved?.metadata?.step ?? -1;
        // merge configurable fields with previous checkpoint config
        const checkpointConfig = {
            ...config,
            configurable: {
                ...config.configurable,
                // TODO: add proper support for updating nested subgraph state
                checkpoint_ns: "",
                ...saved?.config.configurable,
            },
        };
        // Find last node that updated the state, if not provided
        if (values == null && asNode === undefined) {
            return await this.checkpointer.put(checkpointConfig, (0, base_js_1.createCheckpoint)(checkpoint, undefined, step), {
                source: "update",
                step,
                writes: {},
            }, {});
        }
        const nonNullVersion = Object.values(checkpoint.versions_seen)
            .map((seenVersions) => {
            return Object.values(seenVersions);
        })
            .flat()
            .find((v) => !!v);
        if (asNode === undefined && nonNullVersion === undefined) {
            if (typeof this.inputChannels === "string" &&
                this.nodes[this.inputChannels] !== undefined) {
                asNode = this.inputChannels;
            }
        }
        else if (asNode === undefined) {
            // TODO: Double check
            const lastSeenByNode = Object.entries(checkpoint.versions_seen)
                .map(([n, seen]) => {
                return Object.values(seen).map((v) => {
                    return [v, n];
                });
            })
                .flat()
                .sort(([aNumber], [bNumber]) => (0, langgraph_checkpoint_1.compareChannelVersions)(aNumber, bNumber));
            // if two nodes updated the state at the same time, it's ambiguous
            if (lastSeenByNode) {
                if (lastSeenByNode.length === 1) {
                    // eslint-disable-next-line prefer-destructuring
                    asNode = lastSeenByNode[0][1];
                }
                else if (lastSeenByNode[lastSeenByNode.length - 1][0] !==
                    lastSeenByNode[lastSeenByNode.length - 2][0]) {
                    // eslint-disable-next-line prefer-destructuring
                    asNode = lastSeenByNode[lastSeenByNode.length - 1][1];
                }
            }
        }
        if (asNode === undefined) {
            throw new errors_js_1.InvalidUpdateError(`Ambiguous update, specify "asNode"`);
        }
        if (this.nodes[asNode] === undefined) {
            throw new errors_js_1.InvalidUpdateError(`Node "${asNode.toString()}" does not exist`);
        }
        // update channels
        const channels = (0, base_js_1.emptyChannels)(this.channels, checkpoint);
        // run all writers of the chosen node
        const writers = this.nodes[asNode].getWriters();
        if (!writers.length) {
            throw new errors_js_1.InvalidUpdateError(`No writers found for node "${asNode.toString()}"`);
        }
        const task = {
            name: asNode,
            input: values,
            proc: 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            writers.length > 1 ? runnables_1.RunnableSequence.from(writers) : writers[0],
            writes: [],
            triggers: [constants_js_1.INTERRUPT],
            id: (0, langgraph_checkpoint_1.uuid5)(constants_js_1.INTERRUPT, checkpoint.id),
        };
        // execute task
        await task.proc.invoke(task.input, (0, runnables_1.patchConfig)(config, {
            runName: config.runName ?? `${this.getName()}UpdateState`,
            configurable: {
                [constants_js_1.CONFIG_KEY_SEND]: (items) => task.writes.push(...items),
                [constants_js_1.CONFIG_KEY_READ]: algo_js_1._localRead.bind(undefined, checkpoint, channels, 
                // TODO: Why does keyof StrRecord allow number and symbol?
                task),
            },
        }));
        // apply to checkpoint and save
        // TODO: Why does keyof StrRecord allow number and symbol?
        (0, algo_js_1._applyWrites)(checkpoint, channels, [task], this.checkpointer.getNextVersion.bind(this.checkpointer));
        const newVersions = (0, utils_js_1.getNewChannelVersions)(checkpointPreviousVersions, checkpoint.channel_versions);
        return await this.checkpointer.put(checkpointConfig, (0, base_js_1.createCheckpoint)(checkpoint, channels, step + 1), {
            source: "update",
            step: step + 1,
            writes: { [asNode]: values },
        }, newVersions);
    }
    _defaults(config) {
        const { debug, streamMode, inputKeys, outputKeys, interruptAfter, interruptBefore, ...rest } = config;
        const defaultDebug = debug !== undefined ? debug : this.debug;
        let defaultOutputKeys = outputKeys;
        if (defaultOutputKeys === undefined) {
            defaultOutputKeys = this.streamChannelsAsIs;
        }
        else {
            (0, validate_js_1.validateKeys)(defaultOutputKeys, this.channels);
        }
        let defaultInputKeys = inputKeys;
        if (defaultInputKeys === undefined) {
            defaultInputKeys = this.inputChannels;
        }
        else {
            (0, validate_js_1.validateKeys)(defaultInputKeys, this.channels);
        }
        const defaultInterruptBefore = interruptBefore ?? this.interruptBefore ?? [];
        const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];
        let defaultStreamMode;
        if (streamMode !== undefined) {
            defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];
        }
        else {
            defaultStreamMode = this.streamMode;
        }
        let defaultCheckpointer;
        if (config.configurable !== undefined &&
            config.configurable[constants_js_1.CONFIG_KEY_READ] !== undefined) {
            defaultStreamMode = ["values"];
        }
        if (config !== undefined &&
            config.configurable?.[constants_js_1.CONFIG_KEY_CHECKPOINTER] !== undefined &&
            (defaultInterruptAfter.length > 0 || defaultInterruptBefore.length > 0)) {
            defaultCheckpointer = config.configurable[constants_js_1.CONFIG_KEY_CHECKPOINTER];
        }
        else {
            defaultCheckpointer = this.checkpointer;
        }
        return [
            defaultDebug,
            defaultStreamMode,
            defaultInputKeys,
            defaultOutputKeys,
            rest,
            defaultInterruptBefore,
            defaultInterruptAfter,
            defaultCheckpointer,
        ];
    }
    /**
     * Stream graph steps for a single input.
     * @param input The input to the graph.
     * @param options The configuration to use for the run.
     * @param options.streamMode The mode to stream output. Defaults to value set on initialization.
     *   Options are "values", "updates", and "debug". Default is "values".
     *     values: Emit the current values of the state for each step.
     *     updates: Emit only the updates to the state for each step.
     *         Output is a dict with the node name as key and the updated values as value.
     *     debug: Emit debug events for each step.
     * @param options.outputKeys The keys to stream. Defaults to all non-context channels.
     * @param options.interruptBefore Nodes to interrupt before.
     * @param options.interruptAfter Nodes to interrupt after.
     * @param options.debug Whether to print debug information during execution.
     */
    async stream(input, options) {
        return super.stream(input, options);
    }
    async *_streamIterator(input, options) {
        const inputConfig = (0, runnables_1.ensureConfig)(options);
        if (inputConfig.recursionLimit === undefined ||
            inputConfig.recursionLimit < 1) {
            throw new Error(`Passed "recursionLimit" must be at least 1.`);
        }
        if (this.checkpointer !== undefined &&
            inputConfig.configurable === undefined) {
            throw new Error(`Checkpointer requires one or more of the following "configurable" keys: "thread_id", "checkpoint_ns", "checkpoint_id"`);
        }
        const callbackManager = await (0, runnables_1.getCallbackManagerForConfig)(inputConfig);
        const runManager = await callbackManager?.handleChainStart(this.toJSON(), (0, utils_js_1._coerceToDict)(input, "input"), inputConfig.runId, undefined, undefined, undefined, inputConfig?.runName ?? this.getName());
        delete inputConfig.runId;
        // assign defaults
        const [debug, streamMode, , outputKeys, config, interruptBefore, interruptAfter, checkpointer,] = this._defaults(inputConfig);
        let loop;
        let backgroundError;
        const onBackgroundError = (e) => {
            backgroundError = e;
        };
        try {
            loop = await loop_js_1.PregelLoop.initialize({
                input,
                config,
                checkpointer,
                graph: this,
                onBackgroundError,
                outputKeys,
                streamKeys: this.streamChannelsAsIs,
            });
            while (backgroundError === undefined &&
                (await loop.tick({
                    interruptAfter,
                    interruptBefore,
                    manager: runManager,
                }))) {
                if (debug) {
                    (0, debug_js_1.printStepCheckpoint)(loop.checkpointMetadata.step, loop.channels, this.streamChannelsList);
                }
                while (loop.stream.length > 0) {
                    const nextItem = loop.stream.shift();
                    if (nextItem === undefined) {
                        throw new Error("Data structure error.");
                    }
                    if (streamMode.includes(nextItem[0])) {
                        if (streamMode.length === 1) {
                            yield nextItem[1];
                        }
                        else {
                            yield nextItem;
                        }
                    }
                }
                if (debug) {
                    (0, debug_js_1.printStepTasks)(loop.step, loop.tasks);
                }
                // execute tasks, and wait for one to fail or all to finish.
                // each task is independent from all other concurrent tasks
                // yield updates/debug output as each task finishes
                const taskStream = (0, retry_js_1.executeTasksWithRetry)(loop.tasks.filter((task) => task.writes.length === 0), {
                    stepTimeout: this.stepTimeout,
                    signal: config.signal,
                    retryPolicy: this.retryPolicy,
                });
                // Timeouts will be thrown
                for await (const { task, error } of taskStream) {
                    if (error !== undefined) {
                        if ((0, errors_js_1.isGraphInterrupt)(error)) {
                            loop.putWrites(task.id, error.interrupts.map((interrupt) => [constants_js_1.INTERRUPT, interrupt]));
                        }
                        else {
                            loop.putWrites(task.id, [
                                [constants_js_1.ERROR, { message: error.message, name: error.name }],
                            ]);
                        }
                    }
                    else {
                        loop.putWrites(task.id, task.writes);
                    }
                    while (loop.stream.length > 0) {
                        const nextItem = loop.stream.shift();
                        if (nextItem === undefined) {
                            throw new Error("Data structure error.");
                        }
                        if (streamMode.includes(nextItem[0])) {
                            if (streamMode.length === 1) {
                                yield nextItem[1];
                            }
                            else {
                                yield nextItem;
                            }
                        }
                    }
                    if (error !== undefined && !(0, errors_js_1.isGraphInterrupt)(error)) {
                        throw error;
                    }
                }
                if (debug) {
                    (0, debug_js_1.printStepWrites)(loop.step, loop.tasks.map((task) => task.writes).flat(), this.streamChannelsList);
                }
            }
            // Checkpointing failures
            if (backgroundError !== undefined) {
                throw backgroundError;
            }
            while (loop.stream.length > 0) {
                const nextItem = loop.stream.shift();
                if (nextItem === undefined) {
                    throw new Error("Data structure error.");
                }
                if (streamMode.includes(nextItem[0])) {
                    if (streamMode.length === 1) {
                        yield nextItem[1];
                    }
                    else {
                        yield nextItem;
                    }
                }
            }
            if (loop.status === "out_of_steps") {
                throw new errors_js_1.GraphRecursionError([
                    `Recursion limit of ${config.recursionLimit} reached`,
                    "without hitting a stop condition. You can increase the",
                    `limit by setting the "recursionLimit" config key.`,
                ].join(" "));
            }
            await runManager?.handleChainEnd((0, io_js_1.readChannels)(loop.channels, outputKeys));
        }
        catch (e) {
            await runManager?.handleChainError(e);
            throw e;
        }
        finally {
            await loop?.backgroundTasksPromise;
        }
    }
    /**
     * Run the graph with a single input and config.
     * @param input The input to the graph.
     * @param options The configuration to use for the run.
     * @param options.streamMode The mode to stream output. Defaults to value set on initialization.
     *   Options are "values", "updates", and "debug". Default is "values".
     *     values: Emit the current values of the state for each step.
     *     updates: Emit only the updates to the state for each step.
     *         Output is a dict with the node name as key and the updated values as value.
     *     debug: Emit debug events for each step.
     * @param options.outputKeys The keys to stream. Defaults to all non-context channels.
     * @param options.interruptBefore Nodes to interrupt before.
     * @param options.interruptAfter Nodes to interrupt after.
     * @param options.debug Whether to print debug information during execution.
     */
    async invoke(input, options) {
        const streamMode = options?.streamMode ?? "values";
        const config = {
            ...(0, runnables_1.ensureConfig)(options),
            outputKeys: options?.outputKeys ?? this.outputChannels,
            streamMode,
        };
        const chunks = [];
        const stream = await this.stream(input, config);
        for await (const chunk of stream) {
            chunks.push(chunk);
        }
        if (streamMode === "values") {
            return chunks[chunks.length - 1];
        }
        return chunks;
    }
}
exports.Pregel = Pregel;
