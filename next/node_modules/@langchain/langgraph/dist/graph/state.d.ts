import { RunnableLike } from "@langchain/core/runnables";
import { BaseCheckpointSaver } from "@langchain/langgraph-checkpoint";
import { BaseChannel } from "../channels/base.js";
import { END, CompiledGraph, Graph, START, Branch, AddNodeOptions, NodeSpec } from "./graph.js";
import { All } from "../pregel/types.js";
import { AnnotationRoot, SingleReducer, StateDefinition, StateType, UpdateType } from "./annotation.js";
import type { RetryPolicy } from "../pregel/utils.js";
export type ChannelReducers<Channels extends object> = {
    [K in keyof Channels]: SingleReducer<Channels[K], any>;
};
export interface StateGraphArgs<Channels extends object | unknown> {
    channels: Channels extends object ? Channels extends unknown[] ? ChannelReducers<{
        __root__: Channels;
    }> : ChannelReducers<Channels> : ChannelReducers<{
        __root__: Channels;
    }>;
}
export type StateGraphNodeSpec<RunInput, RunOutput> = NodeSpec<RunInput, RunOutput> & {
    input?: any;
    retryPolicy?: RetryPolicy;
};
export type StateGraphAddNodeOptions = {
    retryPolicy?: RetryPolicy;
} & AddNodeOptions;
/**
 * A graph whose nodes communicate by reading and writing to a shared state.
 * Each node takes a defined `State` as input and returns a `Partial<State>`.
 *
 * Each state key can optionally be annotated with a reducer function that
 * will be used to aggregate the values of that key received from multiple nodes.
 * The signature of a reducer function is (left: Value, right: UpdateValue) => Value.
 *
 * See {@link Annotation} for more on defining state.
 *
 * After adding nodes and edges to your graph, you must call `.compile()` on it before
 * you can use it.
 *
 * @example
 * ```ts
 * import {
 *   type BaseMessage,
 *   AIMessage,
 *   HumanMessage,
 * } from "@langchain/core/messages";
 * import { StateGraph, Annotation } from "@langchain/langgraph";
 *
 * // Define a state with a single key named "messages" that will
 * // combine a returned BaseMessage or arrays of BaseMessages
 * const StateAnnotation = Annotation.Root({
 *   sentiment: Annotation<string>,
 *   messages: Annotation<BaseMessage[]>({
 *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {
 *       if (Array.isArray(right)) {
 *         return left.concat(right);
 *       }
 *       return left.concat([right]);
 *     },
 *     default: () => [],
 *   }),
 * });
 *
 * const graphBuilder = new StateGraph(StateAnnotation);
 *
 * // A node in the graph that returns an object with a "messages" key
 * // will update the state by combining the existing value with the returned one.
 * const myNode = (state: typeof StateAnnotation.State) => {
 *   return {
 *     messages: [new AIMessage("Some new response")],
 *     sentiment: "positive",
 *   };
 * };
 *
 * const graph = graphBuilder
 *   .addNode("myNode", myNode)
 *   .addEdge("__start__", "myNode")
 *   .addEdge("myNode", "__end__")
 *   .compile();
 *
 * await graph.invoke({ messages: [new HumanMessage("how are you?")] });
 *
 * // {
 * //   messages: [HumanMessage("how are you?"), AIMessage("Some new response")],
 * //   sentiment: "positive",
 * // }
 * ```
 */
export declare class StateGraph<SD extends StateDefinition | unknown, S = SD extends StateDefinition ? StateType<SD> : SD, U = SD extends StateDefinition ? UpdateType<SD> : Partial<S>, N extends string = typeof START> extends Graph<N, S, U, StateGraphNodeSpec<S, U>> {
    channels: Record<string, BaseChannel>;
    waitingEdges: Set<[N[], N]>;
    constructor(fields: SD extends StateDefinition ? SD | AnnotationRoot<SD> | StateGraphArgs<S> : StateGraphArgs<S>);
    get allEdges(): Set<[string, string]>;
    addNode<K extends string, NodeInput = S>(key: K, action: RunnableLike<NodeInput, U>, options?: StateGraphAddNodeOptions): StateGraph<SD, S, U, N | K>;
    addEdge(startKey: typeof START | N | N[], endKey: N | typeof END): this;
    compile({ checkpointer, interruptBefore, interruptAfter, }?: {
        checkpointer?: BaseCheckpointSaver;
        interruptBefore?: N[] | All;
        interruptAfter?: N[] | All;
    }): CompiledStateGraph<S, U, N>;
}
export declare class CompiledStateGraph<S, U, N extends string = typeof START> extends CompiledGraph<N, S, U> {
    builder: StateGraph<unknown, S, U, N>;
    attachNode(key: typeof START, node?: never): void;
    attachNode(key: N, node: StateGraphNodeSpec<S, U>): void;
    attachEdge(start: N | N[] | "__start__", end: N | "__end__"): void;
    attachBranch(start: N | typeof START, name: string, branch: Branch<S, N>): void;
}
