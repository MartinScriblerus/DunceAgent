"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonPlusSerializer = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable no-instanceof/no-instanceof */
const load_1 = require("@langchain/core/load");
function isLangChainSerializable(value) {
    return (typeof value.lc_serializable === "boolean" && Array.isArray(value.lc_id));
}
function isLangChainSerializedObject(value) {
    return (value !== null &&
        value.lc === 1 &&
        value.type === "constructor" &&
        Array.isArray(value.id));
}
const _serialize = (value, seen = new WeakSet()) => {
    const defaultValue = _default("", value);
    if (defaultValue === null) {
        return "null";
    }
    else if (typeof defaultValue === "string") {
        return JSON.stringify(defaultValue);
    }
    else if (typeof defaultValue === "number" ||
        typeof defaultValue === "boolean") {
        return defaultValue.toString();
    }
    else if (typeof defaultValue === "object") {
        if (seen.has(defaultValue)) {
            throw new TypeError("Circular reference detected");
        }
        seen.add(defaultValue);
        if (Array.isArray(defaultValue)) {
            const result = `[${defaultValue
                .map((item) => _serialize(item, seen))
                .join(",")}]`;
            seen.delete(defaultValue);
            return result;
        }
        else if (isLangChainSerializable(defaultValue)) {
            return JSON.stringify(defaultValue);
        }
        else {
            const entries = Object.entries(defaultValue).map(([k, v]) => `${JSON.stringify(k)}:${_serialize(v, seen)}`);
            const result = `{${entries.join(",")}}`;
            seen.delete(defaultValue);
            return result;
        }
    }
    // Only be reached for functions or symbols
    return JSON.stringify(defaultValue);
};
async function _reviver(value) {
    if (value && typeof value === "object") {
        if (value.lc === 2 && value.type === "undefined") {
            return undefined;
        }
        else if (value.lc === 2 &&
            value.type === "constructor" &&
            Array.isArray(value.id)) {
            try {
                const constructorName = value.id[value.id.length - 1];
                let constructor;
                switch (constructorName) {
                    case "Set":
                        constructor = Set;
                        break;
                    case "Map":
                        constructor = Map;
                        break;
                    case "RegExp":
                        constructor = RegExp;
                        break;
                    case "Error":
                        constructor = Error;
                        break;
                    default:
                        return value;
                }
                if (value.method) {
                    return constructor[value.method](...(value.args || []));
                }
                else {
                    return new constructor(...(value.args || []));
                }
            }
            catch (error) {
                return value;
            }
        }
        else if (isLangChainSerializedObject(value)) {
            return (0, load_1.load)(JSON.stringify(value));
        }
        else if (Array.isArray(value)) {
            return Promise.all(value.map((item) => _reviver(item)));
        }
        else {
            const revivedObj = {};
            for (const [k, v] of Object.entries(value)) {
                revivedObj[k] = await _reviver(v);
            }
            return revivedObj;
        }
    }
    return value;
}
function _encodeConstructorArgs(
// eslint-disable-next-line @typescript-eslint/ban-types
constructor, method, args, kwargs) {
    return {
        lc: 2,
        type: "constructor",
        id: [constructor.name],
        method: method ?? null,
        args: args ?? [],
        kwargs: kwargs ?? {},
    };
}
function _default(_key, obj) {
    if (obj === undefined) {
        return {
            lc: 2,
            type: "undefined",
        };
    }
    else if (obj instanceof Set || obj instanceof Map) {
        return _encodeConstructorArgs(obj.constructor, undefined, [
            Array.from(obj),
        ]);
    }
    else if (obj instanceof RegExp) {
        return _encodeConstructorArgs(RegExp, undefined, [obj.source, obj.flags]);
    }
    else if (obj instanceof Error) {
        return _encodeConstructorArgs(obj.constructor, undefined, [obj.message]);
    }
    else {
        return obj;
    }
}
class JsonPlusSerializer {
    _dumps(obj) {
        const encoder = new TextEncoder();
        return encoder.encode(_serialize(obj));
    }
    dumpsTyped(obj) {
        if (obj instanceof Uint8Array) {
            return ["bytes", obj];
        }
        else {
            return ["json", this._dumps(obj)];
        }
    }
    async _loads(data) {
        const parsed = JSON.parse(data);
        return _reviver(parsed);
    }
    async loadsTyped(type, data) {
        if (type === "bytes") {
            return typeof data === "string" ? new TextEncoder().encode(data) : data;
        }
        else if (type === "json") {
            return this._loads(typeof data === "string" ? data : new TextDecoder().decode(data));
        }
        else {
            throw new Error(`Unknown serialization type: ${type}`);
        }
    }
}
exports.JsonPlusSerializer = JsonPlusSerializer;
