"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/riscript";
exports.ids = ["vendor-chunks/riscript"];
exports.modules = {

/***/ "(ssr)/./node_modules/riscript/dist/riscript.js":
/*!************************************************!*\
  !*** ./node_modules/riscript/dist/riscript.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RiGrammar: () => (/* binding */ RiGrammar),\n/* harmony export */   RiScript: () => (/* binding */ RiScript)\n/* harmony export */ });\n/* harmony import */ var he__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! he */ \"(ssr)/./node_modules/he/he.js\");\n/* harmony import */ var mingo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! mingo */ \"(ssr)/./node_modules/mingo/dist/cjs/index.js\");\n/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! chevrotain */ \"(ssr)/./node_modules/chevrotain/lib/src/api.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/riscript.js\n\n\n\n\n// src/parser.js\n\nvar RiScriptParser = class extends chevrotain__WEBPACK_IMPORTED_MODULE_2__.CstParser {\n  constructor(allTokens, textTypes) {\n    super(allTokens, { nodeLocationTracking: \"full\" });\n    this.atomTypes = [\"silent\", \"assign\", \"symbol\", \"choice\", \"pgate\", \"text\", \"entity\"];\n    this.textTypes = textTypes;\n    this.buildRules();\n  }\n  parse(opts) {\n    this.input = opts.tokens;\n    let cst = this.script();\n    if (this.errors.length > 0)\n      throw Error(\"[PARSING]\\n\" + this.errors[0].message);\n    return cst;\n  }\n  /*\n    Specification:\n      script: expr+\n      expr: atom+\n      atom: (choice | symbol | text | silent | entity | pgate | assign)\n      wexpr: (expr | Weight)*\n      symbol: Symbol transform*\n      choice: [ gate? orExpr elseExpr? ] transform*\n      assign: Symbol EQ expr\n      silent: { gate? (symbol | assign) }\n      orExpr: wexpr (OR wexpr)*\n      elseExpr: ELSE orExpr\n      pgate: PGate\n      entity: Entity\n      gate: Mingo\n      text: Raw | STAT | AMP \n  */\n  buildRules() {\n    const $ = this, Tokens = this.tokensMap;\n    $.RULE(\"script\", () => {\n      $.MANY(() => $.SUBRULE($.expr));\n    });\n    $.RULE(\"expr\", () => {\n      $.AT_LEAST_ONE(() => $.SUBRULE($.atom));\n    });\n    $.RULE(\"atom\", () => {\n      $.OR(this.atomTypes.map((t) => ({ ALT: () => $.SUBRULE($[t]) })));\n    });\n    $.RULE(\"wexpr\", () => {\n      $.MANY(() => {\n        $.OR([\n          { ALT: () => $.SUBRULE($.expr) },\n          { ALT: () => $.CONSUME(Tokens.Weight) }\n        ]);\n      });\n    });\n    $.RULE(\"symbol\", () => {\n      $.CONSUME(Tokens.Symbol);\n      $.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n    $.RULE(\"choice\", () => {\n      $.CONSUME(Tokens.OC);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.SUBRULE($.orExpr);\n      $.OPTION2(() => {\n        $.SUBRULE2($.elseExpr);\n      });\n      $.CONSUME(Tokens.CC);\n      $.MANY(() => $.CONSUME(Tokens.Transform));\n    });\n    $.RULE(\"assign\", () => {\n      $.CONSUME(Tokens.Symbol);\n      $.CONSUME(Tokens.EQ);\n      $.SUBRULE($.expr);\n    });\n    $.RULE(\"silent\", () => {\n      $.CONSUME(Tokens.OS);\n      $.OPTION1(() => $.SUBRULE($.gate));\n      $.CONSUME(Tokens.Symbol);\n      $.OPTION2(() => {\n        $.CONSUME(Tokens.EQ);\n        $.SUBRULE($.expr);\n      });\n      $.CONSUME(Tokens.CS);\n    });\n    $.RULE(\"orExpr\", () => {\n      $.MANY_SEP({\n        SEP: Tokens.OR,\n        DEF: () => $.SUBRULE($.wexpr)\n      });\n    });\n    $.RULE(\"elseExpr\", () => {\n      $.CONSUME(Tokens.ELSE);\n      $.SUBRULE($.orExpr);\n    });\n    $.RULE(\"pgate\", () => {\n      $.CONSUME(Tokens.PendingGate);\n    });\n    $.RULE(\"entity\", () => {\n      $.CONSUME(Tokens.Entity);\n    });\n    $.RULE(\"gate\", () => {\n      $.MANY(() => $.CONSUME(Tokens.Gate));\n    });\n    $.RULE(\"text\", () => {\n      $.OR(this.textTypes.map((t) => ({ ALT: () => $.CONSUME(Tokens[t]) })));\n    });\n    this.performSelfAnalysis();\n  }\n};\n\n// src/util.js\nvar _Util = class _Util {\n  ///////////////////////// FUNCTIONS /////////////////////////\n  static formatAny(o) {\n    if (typeof o === \"string\")\n      return `'${o}'`;\n    else if (typeof o === \"number\")\n      return o;\n    if (typeof o === \"function\")\n      throw Error(\"unexpected function\");\n    return JSON.stringify(o).replace(/\"/g, \"\");\n  }\n  static transformNames(txs) {\n    return txs && txs.length ? txs.map((tx) => tx.image.replace(/(^\\.|\\(\\)$)/g, \"\"), []) : [];\n  }\n  static escapeText(s, quotify) {\n    if (typeof s !== \"string\")\n      return _Util.formatAny(s);\n    let t = s.replace(/\\r?\\n/g, \"\\\\n\");\n    return quotify || !t.length ? \"'\" + t + \"'\" : t;\n  }\n  static stringHash(s) {\n    let chr, hash = 0;\n    for (let i = 0; i < s.length; i++) {\n      chr = s.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0;\n    }\n    let strHash = hash.toString().padStart(9, \"0\");\n    return hash < 0 ? strHash.replace(\"-\", \"0\") : strHash;\n  }\n  static escapeMarkdownLink(txt) {\n    let result = txt;\n    let lookups = { \"[\": \"&lsqb;\", \"]\": \"&rsqb;\", \"(\": \"&lpar;\", \")\": \"&rpar;\", \"/\": \"&sol;\" };\n    Object.entries(lookups).forEach(([k, v]) => result = result.replace(new RegExp(`\\\\${k}`, \"g\"), v));\n    return result;\n  }\n  static slashEscToEntities(s) {\n    s = _Util.replaceAll(s, \"\\\\(\", \"&lpar;\");\n    s = _Util.replaceAll(s, \"\\\\)\", \"&rpar;\");\n    s = _Util.replaceAll(s, \"\\\\[\", \"&lsqb;\");\n    s = _Util.replaceAll(s, \"\\\\]\", \"&rsqb;\");\n    s = _Util.replaceAll(s, \"\\\\{\", \"&lcqb;\");\n    s = _Util.replaceAll(s, \"\\\\}\", \"&rcqb;\");\n    s = _Util.replaceAll(s, \"\\\\@\", \"&commat;\");\n    s = _Util.replaceAll(s, \"\\\\#\", \"&num;\");\n    s = _Util.replaceAll(s, \"\\\\|\", \" &vert\");\n    s = _Util.replaceAll(s, \"\\\\=\", \" &equals\");\n    return s;\n  }\n  static escapeJSONRegex(text) {\n    return text.replace(\n      /\\/([^/]+?)\\/([igmsuy]*)/g,\n      `\"${_Util.RegexEscape}$1${_Util.RegexEscape}$2${_Util.RegexEscape}\"`\n    );\n  }\n  static escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n  static replaceAll(str, match, replacement) {\n    return str.replace(new RegExp(_Util.escapeRegExp(match), \"g\"), () => replacement);\n  }\n};\n///////////////////////// CONSTANTS /////////////////////////\n/**\n * @static\n * @memberof Util\n * @package\n */\n__publicField(_Util, \"RegexEscape\", \"_RE_\");\nvar Util = _Util;\n\n// src/visitor.js\nvar { escapeText, stringHash, formatAny, transformNames } = Util;\nvar BaseVisitor = class {\n  constructor(riScript) {\n    this.input = \"\";\n    this.nowarn = false;\n    this.tracePath = true;\n    this.scripting = riScript;\n    this.warnOnInvalidGates = false;\n    this.maxRecursionDepth = 10;\n  }\n  textFromCstNode(node) {\n    if (Array.isArray(node))\n      node = node[0];\n    return this.input.substring(\n      node.location.startOffset,\n      node.location.endOffset + 1\n    );\n  }\n  isCstNode(o) {\n    if (Array.isArray(o))\n      o = o[0];\n    return typeof o === \"object\" && (\"accept\" in o || \"name\" in o && \"location\" in o && \"children\" in o);\n  }\n  visit(cstNode, options) {\n    if (Array.isArray(cstNode)) {\n      cstNode = cstNode[0];\n    }\n    if (typeof cstNode === \"undefined\") {\n      return void 0;\n    }\n    if (!this.isCstNode(cstNode)) {\n      throw Error(\"Non-cstNode passed to visit: \" + JSON.stringify(cstNode));\n    }\n    this.nodeText = this.textFromCstNode(cstNode);\n    const name = cstNode.name;\n    if (typeof this[name] !== \"function\") {\n      throw Error(`BaseVisitor.visit: expecting function for this[${name}], found ${typeof this[name]}: ${JSON.stringify(this[name])}`);\n    }\n    return this[name](cstNode.children, options);\n  }\n  validateVisitor() {\n  }\n};\nvar RiScriptVisitor = class extends BaseVisitor {\n  constructor(riScript, context = {}) {\n    super(riScript);\n    this.order = 0;\n    this.trace = 0;\n    this.indent = 0;\n    this.choices = {};\n    this.context = context;\n    this.isNoRepeat = false;\n    this.Symbols = this.scripting.Symbols;\n    this.Escaped = this.scripting.Escaped;\n    this.statics = {};\n    this.dynamics = {};\n    this.pendingGates = {};\n    this.validateVisitor();\n  }\n  start(opts = {}) {\n    this.input = opts.input;\n    this.trace = opts.trace;\n    this.nowarn = opts.silent;\n    this.traceTx = opts.traceTx;\n    if (!opts.cst)\n      throw Error(\"no cst\");\n    return super.visit(opts.cst);\n  }\n  script(ctx) {\n    this.order = this.indent = 0;\n    if (Object.keys(ctx).length !== 1)\n      throw Error(\"script: invalid expr\");\n    let count = ctx.expr[0].children.atom.length;\n    this.print(\"script\", `'${escapeText(this.input)}' :: ${count} atom(s)`);\n    if (!count)\n      return \"\";\n    this.indent++;\n    let value = this.visit(ctx.expr);\n    this.indent--;\n    this.print(\"/script\");\n    return value;\n  }\n  expr(ctx) {\n    const types = Object.keys(ctx);\n    if (types.length !== 1)\n      throw Error(\"invalid expr: \" + types.length);\n    const exprs = ctx.atom.map((c) => this.visit(c));\n    if (exprs.length === 1)\n      return exprs[0];\n    for (let i = 1; i < exprs.length - 1; i++) {\n      if (exprs[i].length === 0 && exprs[i - 1].endsWith(\" \") && exprs[i + 1].startsWith(\" \")) {\n        exprs[i + 1] = exprs[i + 1].substring(1);\n      }\n    }\n    return exprs.join(\"\");\n  }\n  atom(ctx) {\n    let result;\n    const types = Object.keys(ctx);\n    if (types.length !== 1)\n      throw Error(\"invalid atom: \" + types);\n    this.scripting.parser.atomTypes.forEach((type) => {\n      if (ctx[type]) {\n        if (ctx[type].length !== 1) {\n          throw Error(type + \": bad length -> \" + ctx[type].length);\n        }\n        result = this.visit(ctx[type][0]);\n        if (typeof result === \"function\") {\n          result = result.call();\n        }\n      }\n    });\n    return result;\n  }\n  silent(ctx) {\n    this.print(\"silent\", this.nodeText);\n    this.indent++;\n    if (ctx.EQ) {\n      this.assign(ctx, { silent: true });\n    } else {\n      this.symbol(ctx, { silent: true });\n    }\n    this.indent--;\n    this.print(\"/silent\", \"statics=\" + formatAny(this.statics));\n    return \"\";\n  }\n  assign(ctx, opts) {\n    const sym = ctx.Symbol[0].image;\n    const original = this.nodeText;\n    const ident = sym.replace(this.scripting.regex.AnySymbol, \"\");\n    const isStatic = sym.startsWith(this.Symbols.STATIC);\n    const isSilent = opts?.silent;\n    let info = `${original} ${isStatic && isSilent ? \"{#static,silent}\" : (isStatic ? \"{#static}\" : \"\") + (isSilent ? \"{silent}\" : \"\")}`;\n    this.print(\"assign\", info);\n    let value;\n    if (isStatic) {\n      if (ident in this.statics && !this.scripting.isParseable(this.statics[ident])) {\n        value = this.statics[ident];\n        info = `${sym} = ${formatAny(value)} {#resolved}`;\n      } else {\n        this.indent++;\n        value = this.visit(ctx.expr);\n        this.indent--;\n        this.statics[ident] = value;\n        if (typeof value === \"string\" && this.scripting.isParseable(value)) {\n          value = this.inlineStaticAssign(ident, ctx.Transform, value);\n        }\n        info = `${sym} = ${formatAny(value)}`;\n      }\n      this.print(\"/assign\", info);\n    } else {\n      const $ = this;\n      this.indent++;\n      value = () => $.visit(ctx.expr);\n      this.indent--;\n      this.dynamics[ident] = value;\n      this.print(\"/assign\", `${sym} =  <f*:pending>`);\n    }\n    return value;\n  }\n  // end assign\n  symbol(ctx, opts) {\n    if (ctx.Symbol.length !== 1)\n      throw Error(\"[1] invalid symbol\");\n    const isSilent = opts?.silent;\n    const original = this.nodeText;\n    const sym = ctx.Symbol[0].image.replace(/\\(\\)$/, \"\");\n    const ident = sym.replace(this.scripting.regex.AnySymbol, \"\");\n    this.isNoRepeat = this.hasNoRepeat(ctx.Transform);\n    this.print(\"symbol\", `${original} ${isSilent ? \" {silent}\" : \"\"}`);\n    let { result, isStatic, isUser, resolved } = this.checkContext(ident);\n    if (!isStatic && this.scripting.regex.StaticSymbol.test(sym)) {\n      if (!this.scripting.regex.Entity.test(sym)) {\n        throw Error(`Attempt to refer to dynamic symbol '${ident}' as ${this.Symbols.STATIC}${ident}, did you mean $${ident}?`);\n      }\n    }\n    for (let i = 0; typeof result === \"function\"; i++) {\n      result = result.call();\n      resolved = !this.scripting.isParseable(result);\n      if (i === this.maxRecursionDepth)\n        throw Error(\"Max recursion depth reached\");\n    }\n    if (this.isNoRepeat && (isStatic || isUser)) {\n      this.isNoRepeat = false;\n      const msg = \"Attempt to call norepeat() on \" + (isStatic ? \"static symbol '\" + sym + \"'. Did you mean to use '\" + this.Symbols.DYNAMIC + ident + \"' ?\" : \"non-dynamic symbol '\" + ident + \"'. Did you mean to define '\" + this.Symbols.DYNAMIC + ident + \"' in riscript?\");\n      throw Error(msg);\n    }\n    if (typeof result === \"undefined\") {\n      this.print(\"/symbol\", sym + \" -> '\" + original + \"' ctx=\" + this.lookupsToString(), \"[deferred]\", opts?.silent ? \"{silent}\" : \"\");\n      return original;\n    }\n    let info = opts?.trace ? `${original.replace(/\\(\\)$/, \"\")} -> ${formatAny(result)}` + (opts?.silent ? \" {silent}\" : \"\") : null;\n    if (typeof result === \"string\" && !resolved) {\n      if (isStatic) {\n        result = this.inlineStaticAssign(ident, ctx.Transform, result);\n        this.print(\"/symbol\", `${original} -> ${result}`);\n      } else {\n        if (ctx.Transform)\n          result = this.restoreTransforms(result, ctx.Transform);\n        this.print(\"/symbol\", info);\n      }\n      return result;\n    }\n    if (isStatic)\n      this.statics[ident] = result;\n    if (ctx.Transform) {\n      result = this.applyTransforms(result, ctx.Transform);\n      info += \"-> '\" + result + \"'\";\n      if (this.isNoRepeat)\n        info += \" (norepeat)\";\n    } else if (result.length === 0 && sym.length === 1) {\n      result = sym;\n      info = \"** $ **\";\n    }\n    this.print(\"/symbol\", info);\n    this.isNoRepeat = false;\n    return result;\n  }\n  // end symbol\n  choice(ctx, opts) {\n    const $ = this.Symbols;\n    const original = this.nodeText;\n    const choiceKey = stringHash(original + \" #\" + this.choiceId(ctx));\n    let gateText, gateResult, hasTransforms = ctx.Transform;\n    if (!this.isNoRepeat && this.hasNoRepeat(ctx.Transform)) {\n      throw Error(\"noRepeat() not allowed on choice (use a $variable instead): \" + original);\n    }\n    this.print(\"choice\", original);\n    let decision = \"accept\";\n    if (opts?.forceReject) {\n      decision = \"reject\";\n    } else {\n      let gateCtx = ctx?.gate?.[0]?.children?.Gate;\n      if (gateCtx) {\n        gateText = gateCtx[0].image;\n        this.indent++;\n        gateResult = this.visit(ctx.gate);\n        this.indent--;\n        decision = gateResult.decision;\n        let ginfo = `${gateText} -> ${decision !== \"defer\" ? decision.toUpperCase() : `DEFER ${$.PENDING_GATE}${choiceKey}`}  ${this.lookupsToString()}`;\n        this.print(\"gate\", ginfo);\n      }\n      if (gateResult && gateResult.decision === \"defer\") {\n        this.pendingGates[choiceKey] = {\n          gateText,\n          deferredContext: ctx,\n          operands: gateResult.operands\n        };\n        return `${$.PENDING_GATE}${choiceKey}`;\n      }\n    }\n    let orExpr = ctx?.orExpr[0];\n    if (decision === \"reject\") {\n      if (!(\"elseExpr\" in ctx))\n        return \"\";\n      orExpr = ctx.elseExpr[0].children.orExpr[0];\n    }\n    const options = this.parseOptions(orExpr);\n    if (!options)\n      throw Error(\"No options in choice: \" + original);\n    let value = null;\n    const excluded = [];\n    let restored = false;\n    while (value === null) {\n      value = this.choose(options, excluded);\n      for (let i = 0; this.isCstNode(value); i++) {\n        this.indent++;\n        value = this.visit(value);\n        this.indent--;\n        if (i === this.maxRecursionDepth)\n          throw Error(\"Max recursion depth reached\");\n      }\n      if (typeof value === \"string\") {\n        value = value.trim();\n      } else if (typeof value !== \"number\") {\n        if (ctx.Transform)\n          value = this.applyTransforms(value, ctx.Transform);\n        hasTransforms = false;\n      }\n      if (this.scripting.isParseable(value)) {\n        if (ctx.Transform)\n          value = this.restoreTransforms(value, ctx.Transform);\n        restored = true;\n        break;\n      }\n      if (hasTransforms)\n        value = this.applyTransforms(value, ctx.Transform);\n      if (this.isNoRepeat && value === this.choices[choiceKey]) {\n        this.print(\"choice-reject\", value + \" [norepeat]\");\n        excluded.push(value);\n        value = null;\n        continue;\n      }\n    }\n    if (!restored)\n      this.choices[choiceKey] = value;\n    this.print(\"choice/\", original + \" -> '\" + value + \"'\");\n    return value;\n  }\n  // end choice\n  choose(options, excludes = []) {\n    if (!options || !options.length) {\n      throw Error(\"Invalid choice: no options\");\n    }\n    const valid = options.filter((x) => !excludes.includes(x));\n    if (!valid.length) {\n      throw Error(\"Invalid choice: no valid options\");\n    }\n    const index = this.scripting.RiTa.randi(valid.length);\n    let value = valid[index];\n    return value;\n  }\n  text(ctx) {\n    if (Object.keys(ctx).length !== 1)\n      throw Error(\"[2] invalid text\");\n    const type = this.scripting.textTypes.filter((t) => ctx[t]);\n    const image = ctx[type][0].image;\n    this.print(\"text/\", escapeText(\"'\" + image + \"'\"));\n    return image;\n  }\n  entity(ctx) {\n    return this.nodeText;\n  }\n  gate(ctx) {\n    if (ctx.Gate.length !== 1)\n      throw Error(\"Invalid gate: \" + ctx.Gate);\n    let raw = ctx.Gate[0].image, mingoQuery;\n    if (raw.startsWith(this.Symbols.OPEN_GATE)) {\n      raw = raw.substring(1);\n    }\n    try {\n      mingoQuery = this.scripting.createQuery(raw);\n    } catch (e) {\n      if (!this.warnOnInvalidGates) {\n        throw Error(`Invalid gate[2]: \"@${raw}\"\n\nRootCause -> ${e}`);\n      }\n      if (!this.scripting.RiTa.SILENT && !this.nowarn) {\n        console.warn(`[WARN] Ignoring invalid gate: @${raw}@\n`, e);\n      }\n      return { decision: \"accept\" };\n    }\n    const resolvedOps = {};\n    const unresolvedOps = [];\n    const operands = mingoQuery.operands();\n    operands.forEach((sym) => {\n      let { result: result2, resolved, isStatic, isUser } = this.checkContext(sym);\n      for (let i = 0; typeof result2 === \"function\"; i++) {\n        result2 = result2.call();\n        resolved = !this.scripting.isParseable(result2);\n        if (i === this.maxRecursionDepth)\n          throw Error(\"Max recursion depth reached\");\n      }\n      if (typeof result2 === \"undefined\" || !resolved) {\n        unresolvedOps.push(sym);\n      } else {\n        if (isStatic) {\n          this.statics[sym] = result2;\n        } else if (isUser) {\n          this.context[sym] = result2;\n        } else {\n          this.dynamics[sym] = result2;\n        }\n        resolvedOps[sym] = result2;\n      }\n    });\n    if (Object.keys(resolvedOps).length + unresolvedOps.length !== operands.length) {\n      throw Error(\"invalid operands\");\n    }\n    if (unresolvedOps.length) {\n      return { decision: \"defer\", operands: unresolvedOps };\n    }\n    let result = mingoQuery.test(resolvedOps);\n    if (!result && this.castValues(resolvedOps)) {\n      result = mingoQuery.test(resolvedOps);\n    }\n    return { decision: result ? \"accept\" : \"reject\" };\n  }\n  pgate(ctx) {\n    this.print(\"pgate\", this.nodeText);\n    const original = this.nodeText;\n    const ident = original.replace(this.Symbols.PENDING_GATE, \"\");\n    const lookup = this.pendingGates[ident];\n    if (!lookup) {\n      throw Error('no pending gate=\"' + original + '\" pgates=' + JSON.stringify(Object.keys(this.pendingGates)));\n    }\n    const stillUnresolved = lookup.operands.some((o) => {\n      let { result, resolved } = this.checkContext(o);\n      if (typeof result === \"function\") {\n        result = result.call();\n        resolved = !this.scripting.isParseable(result);\n      }\n      return typeof result === \"undefined\" || !resolved;\n    });\n    if (stillUnresolved)\n      return original;\n    return this.choice(lookup.deferredContext);\n  }\n  else(ctx) {\n    return this.visit(ctx.expr).trim();\n  }\n  // Helpers ================================================\n  hasNoRepeat(tfs) {\n    const transforms = transformNames(tfs);\n    if (transforms.length) {\n      return transforms.includes(\"nr\") || transforms.includes(\"norepeat\");\n    }\n    return false;\n  }\n  checkContext(ident, opts = {}) {\n    let isStatic = false;\n    let isUser = false;\n    let result;\n    if (ident.length === 0) {\n      return { result: \"\", resolved: true, isStatic, isUser };\n    }\n    result = this.dynamics[ident];\n    if (typeof result === \"undefined\") {\n      result = this.statics[ident];\n      if (typeof result !== \"undefined\") {\n        isStatic = true;\n      }\n    }\n    if (typeof result === \"undefined\") {\n      result = this.context[ident];\n      if (typeof result !== \"undefined\") {\n        isUser = true;\n      }\n    }\n    if (typeof result === \"undefined\") {\n      result = this.scripting.transforms[ident];\n    }\n    const resolved = !this.scripting.isParseable(result);\n    return { result, isStatic, isUser, resolved };\n  }\n  inlineStaticAssign(ident, tfs, result) {\n    const $ = this.Symbols;\n    const lhs = $.STATIC + ident;\n    const rhs = result;\n    let stmt = $.OPEN_CHOICE + (lhs + \"=\" + rhs) + $.CLOSE_CHOICE;\n    result = this.restoreTransforms(stmt, tfs);\n    return result;\n  }\n  choiceId(ctx) {\n    if (!ctx.OC || !ctx.OC.length)\n      throw Error(\"invalid choice\");\n    return ctx.OC[0].startOffset + \".\" + ctx.OC[0].endOffset;\n  }\n  parseOptions(ctx) {\n    const options = [];\n    if (ctx && ctx?.children?.wexpr) {\n      const wexprs = ctx.children.wexpr;\n      for (let i = 0; i < wexprs.length; i++) {\n        const wexpr = wexprs[i];\n        const expr = wexpr.children.expr;\n        if (expr && expr.length != 1) {\n          throw Error(\"invalid choice-expr: \" + expr.length);\n        }\n        const weight = wexpr.children.Weight;\n        if (weight) {\n          if (weight.length != 1) {\n            throw Error(\"invalid weight: \" + weight.length);\n          }\n          let mult = 1;\n          try {\n            mult = parseInt(\n              this.Symbols.CLOSE_WEIGHT.length ? weight[0].image.trim().slice(1, -1) : weight[0].image.trim().slice(1)\n            );\n          } catch (e) {\n            console.log(\"EX: \" + mult);\n          }\n          Array.from({ length: mult }, () => options.push(expr));\n        } else {\n          options.push(expr || \"\");\n        }\n      }\n    }\n    return options;\n  }\n  applyTransforms(value, txs) {\n    this.indent++;\n    if (this.traceTx) {\n      console.log(\"applyTransforms\", this.formatTxs(...arguments));\n    }\n    for (let i = 0; i < txs.length; i++) {\n      value = this.applyTransform(value, txs[i]);\n    }\n    this.indent--;\n    return value;\n  }\n  applyTransform(target, transform) {\n    const image = transform.image;\n    const raw = target + image;\n    const original = formatAny(target) + image;\n    const tx = image.substring(1).replace(/\\(\\)$/, \"\");\n    const RiTa = this.scripting.RiTa;\n    let result;\n    if (typeof this.dynamics[tx] === \"function\") {\n      result = this.dynamics[tx].bind(this.context)(target);\n    } else if (typeof this.statics[tx] === \"function\") {\n      result = this.statics[tx].call(this.context, target);\n    } else if (typeof this.context[tx] === \"function\") {\n      result = this.context[tx].call(this.context, target);\n    } else if (typeof this.scripting.transforms[tx] === \"function\") {\n      result = this.scripting.transforms[tx].call(this.context, target);\n    } else if (typeof target[tx] === \"function\") {\n      result = target[tx]();\n    } else {\n      if (target.hasOwnProperty(tx)) {\n        result = target[tx];\n      } else {\n        if (!RiTa.SILENT && !this.silent) {\n          console.warn(\"[WARN] Unresolved transform: \" + raw);\n        }\n        result = raw.replace(/\\(\\)$/, \"&lpar;&rpar;\");\n      }\n    }\n    this.print(\"transform/\", `${original} -> '${result}'`);\n    return result;\n  }\n  // value is not yet resolved, so store with transform for later\n  restoreTransforms(value, txs) {\n    if (typeof value === \"string\") {\n      const choiceRE = new RegExp(\"^\" + this.Escaped.OPEN_CHOICE + \".*\" + this.Escaped.CLOSE_CHOICE + \"$\");\n      const symbolRE = new RegExp(`(${this.Escaped.DYNAMIC}|${this.Escaped.STATIC}[A-Za-z_0-9])[A-Za-z_0-9]*`);\n      if (!choiceRE.test(value) && !symbolRE.test(value)) {\n        value = this.Symbols.OPEN_CHOICE + value + this.Symbols.CLOSE_CHOICE;\n      }\n      if (txs) {\n        txs.forEach((tx) => value += tx.image);\n      }\n      if (this.traceTx)\n        console.log(\"restoreTransforms:\", value);\n    }\n    return value;\n  }\n  castValues(obj) {\n    let madeCast = false;\n    Object.entries(obj).forEach(([k, v]) => {\n      const num = parseFloat(v);\n      if (!isNaN(num)) {\n        madeCast = true;\n        obj[k] = num;\n      }\n    });\n    return madeCast;\n  }\n  contextIsResolved(table) {\n    let allResolved = true;\n    Object.entries(table).forEach(([key, val]) => {\n      if (!this.scripting.isParseable(val)) {\n        allResolved = false;\n      }\n    });\n    return allResolved;\n  }\n  lookupsToString() {\n    const dyns = {}, stats = {};\n    Object.entries(this.dynamics || {}).forEach(([k, v]) => dyns[`$${k}`] = v);\n    Object.entries(this.statics || {}).forEach(([k, v]) => stats[`#${k}`] = v);\n    return JSON.stringify({ ...this.context, ...stats, ...dyns }, (k, v) => typeof v === \"function\" ? \"<f*:pending>\" : v).replace(/\"/g, \"\");\n  }\n  formatTxs(value, txs) {\n    return value + txs.map((tx) => tx.image.replace(/()/, \"\") + \"()\").join(\"\");\n  }\n  print(s, ...args) {\n    if (this.trace) {\n      let indentStr = \"  \".repeat(this.indent);\n      let msg = `${indentStr}<${s}>${s.startsWith(\"/\") ? \"\" : \" \"}`;\n      if (++this.order < 10)\n        msg = \" \" + msg;\n      console.log(this.order, msg, ...args);\n    }\n  }\n};\n\n// src/tokens.js\n\nfunction getTokens(v2Compatible) {\n  let Symbols = {\n    OR: \"|\",\n    ELSE: \"||\",\n    DYNAMIC: \"$\",\n    STATIC: \"#\",\n    ENTITY: \"&\",\n    OPEN_GATE: \"@\",\n    PENDING_GATE: \"@@\",\n    OPEN_SILENT: \"{\",\n    CLOSE_SILENT: \"}\"\n  };\n  let v2Symbols = {\n    OPEN_CHOICE: \"(\",\n    CLOSE_CHOICE: \")\",\n    OPEN_WEIGHT: \"[\",\n    CLOSE_WEIGHT: \"]\",\n    CONTINUATION: \"\\\\\"\n  };\n  let v3Symbols = {\n    OPEN_CHOICE: \"[\",\n    CLOSE_CHOICE: \"]\",\n    OPEN_WEIGHT: \"^\",\n    // also allows (int), eg. (3)\n    CLOSE_WEIGHT: \"^\",\n    CONTINUATION: \"~\"\n  };\n  Object.assign(Symbols, v2Compatible ? v2Symbols : v3Symbols);\n  const Escaped = {};\n  Object.entries(Symbols).forEach(([k, v]) => {\n    Escaped[k] = escapeRegex(v);\n  });\n  const ENTITY_PATTERN = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/i;\n  const PENDING_GATE_PATTERN = new RegExp(`${Escaped.PENDING_GATE}([0-9]{9,11})`);\n  Escaped.SPECIAL = Object.values(Escaped).join(\"\").replace(/[<>@]/g, \"\");\n  const DYN = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"DYN\", pattern: new RegExp(Escaped.DYNAMIC) });\n  const STAT = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"STAT\", pattern: new RegExp(Escaped.STATIC) });\n  const OC = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"OC\", pattern: new RegExp(Escaped.OPEN_CHOICE + \"\\\\s*\") });\n  const CC = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"CC\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_CHOICE}`) });\n  const OS = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"OS\", pattern: new RegExp(`${Escaped.OPEN_SILENT}\\\\s*`) });\n  const CS = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"CS\", pattern: new RegExp(`\\\\s*${Escaped.CLOSE_SILENT}`) });\n  const ELSE = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"ELSE\", pattern: /\\s*\\|\\|\\s*/ });\n  const OR = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"OR\", pattern: /\\s*\\|\\s*/ });\n  const EQ = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"EQ\", pattern: /\\s*=\\s*/ });\n  const AMP = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"AMP\", pattern: /&/ });\n  const Symbol2 = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"Symbol\", pattern: new RegExp(`(${Escaped.DYNAMIC}|${Escaped.STATIC}[A-Za-z_0-9])[A-Za-z_0-9]*(\\\\(\\\\))?`) });\n  const Transform = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"Transform\", pattern: /\\.[A-Za-z_0-9][A-Za-z_0-9]*(\\(\\))?/ });\n  const Entity = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"Entity\", pattern: ENTITY_PATTERN });\n  const Weight = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"Weight\", pattern: new RegExp(`\\\\s*${Escaped.OPEN_WEIGHT}\\\\d+${Escaped.CLOSE_WEIGHT}\\\\s*`) });\n  const PendingGate = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"PendingGate\", pattern: PENDING_GATE_PATTERN });\n  const Raw = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"Raw\", pattern: new RegExp(`[^${Escaped.SPECIAL}]+`) });\n  const Gate = (0,chevrotain__WEBPACK_IMPORTED_MODULE_2__.createToken)({ name: \"Gate\", line_breaks: true, pattern: bracketMatch });\n  const tokens = [Gate, Entity, Weight, ELSE, OC, CC, OR, EQ, Symbol2, DYN, STAT, AMP, Transform, OS, CS, PendingGate, Raw];\n  return { tokens, Constants: { Symbols, Escaped } };\n}\nfunction bracketMatch(text, startOffset) {\n  if (!/^@/.test(text.substring(startOffset)))\n    return null;\n  let endOffset = startOffset + 1;\n  let dbug = 0;\n  if (dbug)\n    console.log(\"bracketMatch\", text);\n  let charCode = text.charCodeAt(endOffset);\n  while (charCode === 32) {\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n  if (charCode !== 123) {\n    if (dbug)\n      console.log(`  \"${text.substring(startOffset, endOffset)}\" -> null1`);\n    return null;\n  }\n  endOffset++;\n  charCode = text.charCodeAt(endOffset);\n  let depth = 1;\n  while (depth > 0) {\n    if (charCode === 123)\n      depth++;\n    else if (charCode === 125)\n      depth--;\n    if (dbug)\n      console.log(\"  depth\", depth, text.substring(startOffset, endOffset));\n    endOffset++;\n    charCode = text.charCodeAt(endOffset);\n  }\n  if (endOffset === startOffset) {\n    if (dbug)\n      console.log(`\"${text.substring(startOffset, endOffset)}\" -> null3`);\n    return null;\n  } else {\n    let matchedString = text.substring(startOffset, endOffset);\n    if (dbug)\n      console.log(\"  returned -> \", [matchedString]);\n    return [matchedString];\n  }\n}\nfunction escapeRegex(s) {\n  return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nvar TextTypes = [\"Raw\", \"STAT\", \"AMP\"];\n\n// src/grammar.js\nvar _RiGrammar = class _RiGrammar {\n  // assigned in riscript.js\n  /**\n   * Creates an instance of RiGrammar.\n   * @param {Object<string, string>|string} [rules] - an object (or JSON string) containing the rules\n   * @param {Object<string, any>} [context] - the context (or world-state)\n   * @param {Object<string, any>} [options] - options for the grammar\n   */\n  constructor(rules = {}, context = {}, options = {}) {\n    this.rules = {};\n    this.context = context;\n    this.scripting = options.RiTa?.riscript ?? new RiScript(options);\n    if (typeof rules === \"string\") {\n      rules = parseJSON(rules);\n    }\n    if (typeof rules !== \"object\") {\n      throw Error(\"RiGrammar: expecting object, found \" + typeof rules);\n    }\n    this.setRules(rules);\n  }\n  /**\n   * Creates a new RiGrammar from the `rules`, `context` and `options`, then calls `expand()` on it.\n   * @param {string} rules - an object containing the rules\n   * @param {object} [context] - the context (or world-state) for the expansion\n   * @param {object} [options] - options for the expansion\n   * @param {string} [options.start='$start'] - the rule to start from\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation to the console\n   * @param {boolean} [options.onepass=false] - whether to only do one evaluation pass \n   * @param {boolean} [options.silent=false] - whether to suppress console warnings\n   * @returns {string} - the expanded text\n   */\n  static expand(rules, context, options) {\n    return new _RiGrammar(rules, context).expand(options);\n  }\n  /**\n   * Adds a transform to the Grammar instance\n   * @param {string} name - the name of the transform\n   * @param {Function} def - a function that takes a string and returns a string\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  addTransform(name, def) {\n    this.scripting.addTransform(name, def);\n    return this;\n  }\n  /**\n   * Removes a transform from the Grammar instance\n   * @param {string} name \n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  removeTransform(name) {\n    this.scripting.removeTransform(name);\n    return this;\n  }\n  /**\n   * Returns the names of all current transforms\n   * @returns {string[]} the names of the transforms\n   */\n  getTransforms() {\n    return this.scripting.getTransforms();\n  }\n  /**\n   * Tests whether two grammars are equal and returns a boolean\n   * @param {RiGrammar} rg - the grammar to compare to \n   * @returns {boolean} - whether the grammars are equal\n   */\n  equals(rg) {\n    return rg.toJSON() === this.toJSON();\n  }\n  /**\n   * Expands a grammar from the supplied rule. If no rule is provided the `$start` and `<start>`\n   *  symbols will be checked respectively. If a context is needed, it should be passed when the\n   *  grammar is created.\n   * @param {object} [options] - options for the expansion\n   * @param {string} [options.start='$start'] - the rule to start from\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation to the console\n   * @param {boolean} [options.onepass=false] - whether to only do one evaluation pass \n   * @param {boolean} [options.silent=false] - whether to suppress console warnings\n   * @returns {string} - the expanded text\n   */\n  expand(options = {}) {\n    if (\"context\" in options) {\n      throw Error(\"pass context to RiScript.grammar() or new RiGrammar() instead\");\n    }\n    let visitor = new RiScriptVisitor(this.scripting);\n    visitor.context = this.context || {};\n    let clonedOpts = { ...options, visitor, input: this._toScript(options) };\n    return this.scripting._evaluate(clonedOpts);\n  }\n  /**\n   * Validates a rule and adds a new rule to the grammar\n   * @param {string} name - the name of the rule\n   * @param {string} def - the definition of the rule\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  addRule(name, def) {\n    this._validateRule(name, def);\n    this.rules[name] = def;\n    return this;\n  }\n  /**\n   * Sets the rules for the grammar, removing any previous rules\n   * @param {object|string} rules - an object or JSON string holding the rules for the grammar \n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  setRules(rules) {\n    if (typeof rules === \"undefined\")\n      throw Error(\"undefined rules\");\n    this.rules = {};\n    let incoming = typeof rules === \"string\" ? parseJSON(rules) : rules;\n    Object.entries(incoming).forEach((e) => this.addRule(...e));\n    return this;\n  }\n  /**\n   * Removes a rule from the grammar\n   * @param {string} name - the name of the rule to remove\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  removeRule(name) {\n    if (name in this.rules) {\n      delete this.rules[name];\n    }\n    return this;\n  }\n  /**\n   * Returns a JSON representation of the grammar rules, accepting options from `JSON.stringify()`\n   * @param {any} [replacer] - a replacer function or array\n   * @param {string | number} [space] - the number of spaces to indent\n   * @returns {string} - the JSON representation of the grammar\n   */\n  toJSON(replacer, space) {\n    return JSON.stringify(this.rules, replacer, space);\n  }\n  /** \n   * Returns a string representation of the grammar, accecpting the same options as `JSON.stringify()`\n   * @param {object} [options] - options for the string representation\n   * @param {any} [options.replacer] - a replacer function or array\n   * @param {string | number} [options.space] - the number of spaces to indent\n   * @param {string} [options.linebreak] - the linebreak character to use\n   */\n  toString(options = {}) {\n    let replacer = options.replacer || 0;\n    let space = options.space || 2;\n    let lb = options?.linebreak;\n    let res = this.toJSON(replacer, space);\n    if (lb)\n      res = res.replace(/\\n/g, lb);\n    return res;\n  }\n  /**\n   * Creates a new RiGrammar from the supplied JSON string\n   * @param {string} json - a JSON string representing the grammar\n   * @param {object} [context] - optional context for the grammar\n   * @returns {RiGrammar} - the RiGrammar instance\n   */\n  static fromJSON(json, context) {\n    return new _RiGrammar(JSON.parse(json), context);\n  }\n  //////////////////////////////////////////////////////////////////////////////\n  /**\n   * Converts grammar to inline rules; rules are dynamic, unless otherwise specified with leading #\n   * @private\n   */\n  _toScript(opts) {\n    let script = \"\", start = opts.start || \"start\";\n    let { Symbols } = this.scripting;\n    if (start.startsWith(Symbols.DYNAMIC)) {\n      start = start.substring(Symbols.DYNAMIC.length);\n    }\n    if (start.startsWith(Symbols.STATIC)) {\n      start = start.substring(Symbols.STATIC.length);\n    }\n    if (!(start in this.rules || Symbols.STATIC + start in this.rules)) {\n      throw Error('Rule: \"' + start + '\" not found in grammar');\n    }\n    Object.entries(this.rules).forEach(([name, rule], i) => {\n      while (name.startsWith(Symbols.DYNAMIC)) {\n        name = name.substring(1);\n      }\n      if (!name.startsWith(Symbols.STATIC)) {\n        name = Symbols.DYNAMIC + name;\n      }\n      if (!this.scripting.regex.ChoiceWrap.test(rule)) {\n        rule = Symbols.OPEN_CHOICE + rule + Symbols.CLOSE_CHOICE;\n      }\n      script += `${name}=${rule}\n`;\n    });\n    if (opts.trace)\n      console.log(\"Grammar:\\n\" + script.replace(/^\\$/gm, \"  $\"));\n    script += `${Symbols.DYNAMIC}${start}`;\n    return script;\n  }\n  /**\n   * Validates a grammar rule\n   * @private\n   */\n  _validateRule(name, def) {\n    if (typeof name !== \"string\" || name.length === 0) {\n      throw Error(\"expected [string] name\");\n    }\n    if (typeof def === \"undefined\") {\n      throw Error(\"undefined rule def: \" + name);\n    }\n    let { Symbols } = this.scripting;\n    if (name.startsWith(Symbols.DYNAMIC)) {\n      name = name.substring(Symbols.DYNAMIC.length);\n      throw Error(\"Grammar rules are dynamic by default; if you need a static rule, use '\" + Symbols.STATIC + name + \"', otherwise just use '\" + name + \"'.\");\n    }\n  }\n};\n__publicField(_RiGrammar, \"RiScript\", null);\nvar RiGrammar = _RiGrammar;\nfunction parseJSON(json) {\n  if (typeof json === \"string\") {\n    try {\n      return JSON.parse(json);\n    } catch (e) {\n      throw Error(\"RiGrammar appears to be invalid JSON, please check it at http://jsonlint.com/\\n\" + json);\n    }\n  }\n}\n\n// src/riscript.js\nvar { decode } = he__WEBPACK_IMPORTED_MODULE_0__;\nvar Vowels = /[aeiou]/;\nvar HtmlEntities = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi;\nvar { escapeText: escapeText2, slashEscToEntities, escapeMarkdownLink, escapeJSONRegex } = Util;\nvar RiQuery = class extends mingo__WEBPACK_IMPORTED_MODULE_1__.Query {\n  constructor(scripting, condition, options) {\n    if (typeof condition !== \"string\") {\n      try {\n        condition = JSON.stringify(condition);\n      } catch (e) {\n        throw Error(condition.toString().includes(\"@\") ? \"Replace @ with $ when passing an object to RiQuery\\nRoot: \" + e : e);\n      }\n    }\n    if (!condition.includes(\"$\"))\n      throw Error(\"Invalid Gate: '\" + condition + \"' -> operand must include $symbol or $function()\");\n    condition = condition.replace(/(\\$|\\(\\))/g, \"\").replace(/@/g, \"$\");\n    condition = scripting.parseJSOL(condition);\n    super(condition, options);\n  }\n  test(obj) {\n    let compiled = this.compiled;\n    for (let i = 0, len = compiled.length; i < len; i++) {\n      if (!compiled[i](obj))\n        return false;\n    }\n    return true;\n  }\n  operands() {\n    const stack = [this.condition];\n    const keys = /* @__PURE__ */ new Set();\n    while (stack?.length > 0) {\n      const currentObj = stack.pop();\n      Object.keys(currentObj).forEach((key) => {\n        const value = currentObj[key];\n        if (!key.startsWith(\"$\"))\n          keys.add(key);\n        if (typeof value === \"object\" && value !== null) {\n          const eles = Array.isArray(value) ? value : [value];\n          eles.forEach((ele) => stack.push(ele));\n        }\n      });\n    }\n    return Array.from(keys);\n  }\n};\nvar _RiScript = class _RiScript {\n  /**\n   * Create a RiTa grammar instance\n   * @param {object} [rules] - the rules of the grammar\n   * @param {object} [context] - the context of the grammar\n   * @param {object} [options] - options for the evaluation\n   * @returns {RiGrammar} - a new RiGrammar instance\n   */\n  static grammar(rules, context, options) {\n    return new RiGrammar(rules, context, options);\n  }\n  /**\n   * Evaluates the input script via the RiScript parser\n   * @param {string} script - the script to evaluate\n   * @param {object} [context] - the context (or world-state) to evaluate in\n   * @param {object} [options] - options for the evaluation\n   * @param {object} [options.RiTa] - optionals RiTa object to use in transforms\n   * @param {number} [options.compatibility] - the RiTa compatibility level (pass 2 for v2)\n   * @param {boolean} [options.trace=false] - whether to trace the evaluation\n   * @returns {string} - the evaluated script\n   */\n  static evaluate(script, context, options = {}) {\n    return new _RiScript(options).evaluate(script, context, options);\n  }\n  /**\n   * Creates a new RiScript instance\n   * @param {object} [options] - options for the object\n   * @param {object} [options.RiTa] - optionals RiTa object to use in transforms\n   * @param {number} [options.compatibility] - the RiTa compatibility level\n   */\n  constructor(options = {}) {\n    this.Escaped = void 0;\n    this.Symbols = void 0;\n    this.visitor = void 0;\n    this.v2Compatible = options.compatibility === 2;\n    const { Constants, tokens } = getTokens(this.v2Compatible);\n    ({ Escaped: this.Escaped, Symbols: this.Symbols } = Constants);\n    this.pendingGateRe = new RegExp(`${this.Escaped.PENDING_GATE}([0-9]{9,11})`, \"g\");\n    this.textTypes = TextTypes;\n    this.RiTa = options.RiTa || {\n      VERSION: 0,\n      randi: (k) => Math.floor(Math.random() * k)\n    };\n    this.transforms = this._createTransforms();\n    this.regex = this._createRegexes(tokens);\n    this.lexer = new chevrotain__WEBPACK_IMPORTED_MODULE_2__.Lexer(tokens);\n    this.parser = new RiScriptParser(tokens, TextTypes);\n  }\n  /** @private */\n  lex(opts) {\n    if (!opts.input)\n      throw Error(\"no input\");\n    const lexResult = this.lexer.tokenize(opts.input);\n    if (lexResult.errors.length) {\n      console.error(\"Input: \" + opts.input + \"\\n\", lexResult.errors[0].message);\n      throw Error(\"[LEXING] \" + lexResult.errors[0].message);\n    }\n    if (opts.traceLex)\n      this._printTokens(lexResult.tokens);\n    opts.tokens = lexResult.tokens;\n  }\n  /** @private */\n  parse(opts) {\n    opts.cst = this.parser.parse(opts);\n  }\n  /** @private */\n  visit(opts) {\n    return this.visitor.start(opts);\n  }\n  /**\n   * Evaluates the input script via the RiScript parser\n   * @param {string} script - the script to evaluate\n   * @param {object} [context] - the context (or world-state) to evaluate in\n   * @param {object} [options] - options for the evaluation\n   * @returns {string}\n   */\n  evaluate(script, context, options) {\n    if (typeof script !== \"string\") {\n      throw Error(\"evaluate() expects a string, got \" + typeof script);\n    }\n    if (typeof options !== \"object\") {\n      options = {};\n    }\n    options.input = script;\n    options.visitor = new RiScriptVisitor(this, context);\n    return this._evaluate(options);\n  }\n  /** @private */\n  lexParseVisit(opts = {}) {\n    this.lex(opts);\n    this.parse(opts);\n    return this.visit(opts);\n  }\n  /**\n   * Add a transform function to this instance\n   * @param {string} name - the name of the transform\n   * @param {function} def - the transform function\n   * @returns {RiScript} this instance\n   */\n  addTransform(name, def) {\n    this.transforms[name] = def;\n    return this;\n  }\n  /**\n   * Returns the names of all current transforms\n   * @returns {string[]} the names of the transforms\n   */\n  getTransforms() {\n    return Object.keys(this.transforms);\n  }\n  /**\n   * Removes a transform function from this instance\n   * @param {string} name of transform to remove\n   * @returns {RiScript} this instance\n   */\n  removeTransform(name) {\n    delete this.transforms[name];\n    return this;\n  }\n  ///////////////////////////////////// End API //////////////////////////////////////\n  /**\n   * Private version of evaluate taking all arguments in the options object\n   * @param {object} options - options for the evaluation\n   * @param {string} options.input - the script to evaluate\n   * @param {object} options.visitor - the visitor to use for the evaluation\n   * @param {boolean} [options.trace] - whether to trace the evaluation\n   * @param {boolean} [options.onepass] - whether to only do one pass\n   * @param {boolean} [options.silent] - whether to suppress warnings\n   * @returns {string} - the evaluated script's output text\n   * @package\n   */\n  _evaluate(options) {\n    const { input, visitor, trace, onepass, silent } = options;\n    if (!input)\n      throw Error(\"no input\");\n    if (!visitor)\n      throw Error(\"no visitor\");\n    let last, endingBreak = this.regex.EndingBreak.test(input);\n    let expr = this._preParse(input, options);\n    if (!expr)\n      return \"\";\n    if (!options.visitor)\n      throw Error(\"no visitor\");\n    this.visitor = options.visitor;\n    delete options.visitor;\n    if (trace) {\n      console.log(`\nInput:  '${escapeText2(input)}' ctx=${visitor.lookupsToString()}`);\n      if (input !== expr) {\n        console.log(`Parsed: '${escapeText2(expr)}'`);\n      }\n    }\n    for (let i = 1; expr !== last && i <= 10; i++) {\n      last = expr;\n      if (trace)\n        console.log(\"-\".repeat(20) + \" Pass#\" + i + \" \" + \"-\".repeat(20));\n      options.input = expr;\n      expr = this.lexParseVisit(options) ?? \"\";\n      if (trace) {\n        console.log(`Result(${i}) -> \"${escapeText2(expr || \"\")}\" ctx=${this.visitor.lookupsToString()}`);\n      }\n      if (onepass || !this.isParseable(expr))\n        break;\n    }\n    if (!silent && !this.RiTa.SILENT) {\n      if (this.regex.ValidSymbol.test(expr.replace(HtmlEntities, \"\"))) {\n        console.warn('[WARN] Unresolved symbol(s) in \"' + expr.replace(/\\n/g, \"\\\\n\") + '\" ');\n      }\n    }\n    return this._postParse(expr, options) + (endingBreak ? \"\\n\" : \"\");\n  }\n  /** @private */\n  _printTokens(tokens) {\n    let s = tokens.reduce((str, t) => {\n      let { name } = t.tokenType;\n      let tag = name;\n      if (tag === \"TEXT\")\n        tag = escapeText2(t.image, true);\n      if (tag === \"Symbol\")\n        tag = \"sym(\" + t.image + \")\";\n      if (tag === \"TX\")\n        tag = \"tx(\" + t.image + \")\";\n      return str + tag + \", \";\n    }, \"\").slice(0, -2);\n    console.log(\"\\nTokens: [ \" + s + \" ]\\n\");\n  }\n  /** @private */\n  _preParse(script, opts) {\n    if (typeof script !== \"string\")\n      return \"\";\n    const $ = this.Symbols;\n    let input = script;\n    if (!this.v2Compatible) {\n      input = input.replace(this.regex.ParenthesizedWeights, \"^$1^\");\n    }\n    let matches = input.match(this.regex.MarkdownLinks);\n    matches && matches.forEach((m) => input = input.replace(m, escapeMarkdownLink(m)));\n    input = input.replace(this.regex.MultiLineComments, \"\");\n    input = input.replace(this.regex.SingleLineComments, \"\");\n    input = input.replace(this.regex.Continue, \"\");\n    input = slashEscToEntities(input);\n    let result = \"\";\n    let lines = input.split(this.regex.LineBreaks);\n    for (let i = 0; i < lines.length; i++) {\n      if (this.regex.RawAssign.test(lines[i])) {\n        let eqIdx = lines[i].indexOf(\"=\");\n        if (eqIdx < 0)\n          throw Error(\"invalid state: no assigment: \" + lines[i]);\n        let lhs = lines[i].substring(0, eqIdx), rhs = lines[i].substring(eqIdx + 1);\n        let opens = charCount(rhs, $.OPEN_CHOICE);\n        let closes = charCount(rhs, $.CLOSE_CHOICE);\n        while (opens > closes) {\n          let line = lines[++i];\n          rhs += \"\\n\" + line;\n          opens += charCount(line, $.OPEN_CHOICE);\n          closes += charCount(line, $.CLOSE_CHOICE);\n        }\n        result += $.OPEN_SILENT + (lhs + \"=\" + rhs) + $.CLOSE_SILENT;\n      } else {\n        result += lines[i];\n        if (i < lines.length - 1)\n          result += \"\\n\";\n      }\n    }\n    return result;\n  }\n  /**\n   * Creates a new RiQuery object from the raw query string\n   * @package \n   */\n  createQuery(rawQuery, opts) {\n    return new RiQuery(this, rawQuery, opts);\n  }\n  /** @private */\n  _postParse(input, opts) {\n    if (typeof input !== \"string\")\n      return \"\";\n    let decoded = decode(input);\n    let result = decoded.replace(this.regex.Whitespace, \" \").replace(this.regex.EndingBreak, \"\");\n    let gates = [...result.matchAll(this.pendingGateRe)];\n    if (opts.trace && gates.length) {\n      console.log(\"-\".repeat(20) + \" pGates \" + \"-\".repeat(20));\n    }\n    this.visitor.order = 0;\n    gates.forEach((g) => {\n      if (!g || !g[0] || !g[1])\n        throw Error(\"bad gate: \" + g);\n      let deferredGate = this.visitor.pendingGates[g[1]];\n      if (!deferredGate)\n        throw Error(\"no deferredGate: \" + g[1]);\n      let { deferredContext, operands, gateText } = deferredGate;\n      if (!operands.length)\n        throw Error(\"no operands\");\n      let reject = this.visitor.choice(deferredContext, { forceReject: true });\n      result = result.replace(g[0], reject);\n      if (opts.trace)\n        console.log(\"Unresolved gate: '\" + gateText + \"' {reject}\");\n    });\n    if (opts.trace)\n      console.log(`\nFinal: '${result}'`);\n    if (!opts.preserveLookups) {\n      this.visitor.statics = void 0;\n      this.visitor.dynamics = void 0;\n    }\n    return result;\n  }\n  /**\n   * Parses a mingo query into JSON format\n   * @package\n   */\n  parseJSOL(text) {\n    const unescapeRegexProperty = (text2) => {\n      const RegexEscape = Util.RegexEscape;\n      let res = text2;\n      if (typeof text2 === \"string\" && text2.startsWith(RegexEscape) && text2.endsWith(RegexEscape)) {\n        let parts = text2.split(RegexEscape);\n        if (parts.length !== 4)\n          throw Error(\"invalid regex in unescape\");\n        res = new RegExp(parts[1], parts[2]);\n      }\n      return res;\n    };\n    let escaped = escapeJSONRegex(text).replace(this.regex.JSOLIdent, '\"$1\":').replace(/'/g, '\"');\n    let result = JSON.parse(escaped), urp = unescapeRegexProperty;\n    Object.keys(result).forEach((k) => result[k] = urp(result[k]));\n    return result;\n  }\n  /**\n   * True if input contains parseable script\n   * @private\n   */\n  isParseable(s) {\n    let result = true;\n    if (typeof s === \"number\") {\n      s = s.toString();\n    }\n    if (typeof s === \"string\") {\n      result = this.regex.Special.test(s) || s.includes(this.Symbols.PENDING_GATE);\n    }\n    return result;\n  }\n  // ========================= statics ===============================\n  /**\n   * Default transform that pluralizes a string (uses RiTa if available for phonemes)\n   * @param {string} s - the string to transform\n   * @param {object} [pluralizer] - custom pluralizer with pluralize() function\n   * @returns {string} the transformed string\n   * @private\n   */\n  static pluralize(s, pluralizer) {\n    if (!pluralizer?.pluralize) {\n      if (!_RiScript.RiTaWarnings.plurals && !_RiScript.RiTaWarnings.silent) {\n        _RiScript.RiTaWarnings.plurals = true;\n        console.warn(\"[WARN] Install RiTa for proper pluralization\");\n      }\n      return s.endsWith(\"s\") ? s : s + \"s\";\n    }\n    return pluralizer.pluralize(s);\n  }\n  /**\n   * Default transform that adds an article (uses RiTa if available for phonemes)\n   * @param {string} s - the string to transform\n   * @param {object} [phonemeAnalyzer] - custom phoneme analyzer with phones() function\n   * @returns {string} the transformed string\n   * @private\n   */\n  static articlize(s, phonemeAnalyzer) {\n    if (!s || !s.length)\n      return \"\";\n    let first = s.split(/\\s+/)[0];\n    if (!phonemeAnalyzer?.phones) {\n      if (!_RiScript.RiTaWarnings.phones && !_RiScript.RiTaWarnings.silent) {\n        console.warn(\"[WARN] Install RiTa for proper phonemes\");\n        _RiScript.RiTaWarnings.phones = true;\n      }\n      return (/^[aeiou].*/i.test(first) ? \"an \" : \"a \") + s;\n    }\n    let phones = phonemeAnalyzer.phones(first, { silent: true });\n    return (phones?.length && Vowels.test(phones[0]) ? \"an \" : \"a \") + s;\n  }\n  /**\n   * Default transform that uppercases the first character of the string\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static capitalize(s) {\n    return s ? s[0].toUpperCase() + s.substring(1) : \"\";\n  }\n  /**\n   * Default transform that capitalizes the string\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static uppercase(s) {\n    return s ? s.toUpperCase() : \"\";\n  }\n  /**\n   * Default transform that wraps the string in (smart) quotes.\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static quotify(s) {\n    return \"&#8220;\" + (s || \"\") + \"&#8221;\";\n  }\n  /**\n   * Default no-op transform\n   * @param {string} s - the string to transform\n   * @returns {string} the transformed string\n   * @private\n   */\n  static identity(s) {\n    return s;\n  }\n  // ========================= helpers ===============================\n  /** @private */\n  _createRegexes(tokens) {\n    const Esc = this.Escaped;\n    const open = Esc.OPEN_CHOICE;\n    const close = Esc.CLOSE_CHOICE;\n    const anysym = Esc.STATIC + Esc.DYNAMIC;\n    return {\n      LineBreaks: /\\r?\\n/,\n      EndingBreak: /\\r?\\n$/,\n      NonGateAtSigns: /([^}])@(?!{)/,\n      AnySymbol: new RegExp(`[${anysym}]`),\n      ParenthesizedWeights: /\\(\\s*(\\d+)\\s*\\)/g,\n      // TODO: change for negative weights\n      MultiLineComments: /\\/\\*[^]*?(\\r?\\n)?\\//g,\n      SingleLineComments: /\\/\\/[^\\n]+(\\r?\\n|$)/g,\n      MarkdownLinks: /\\[([^\\]]+)\\]\\(([^)\"]+)(?: \\\"([^\\\"]+)\\\")?\\)/g,\n      RawAssign: new RegExp(`^[${anysym}][A-Za-z_0-9][A-Za-z_0-9]*\\\\s*=`),\n      JSOLIdent: new RegExp(`([${anysym}]?[A-Za-z_0-9][A-Za-z_0-9]*)\\\\s*:`, \"g\"),\n      ChoiceWrap: new RegExp(\"^\" + open + \"[^\" + open + close + \"]*\" + close + \"$\"),\n      ValidSymbol: new RegExp(\"(\" + Esc.DYNAMIC + \"|\" + Esc.STATIC + \"[A-Za-z_0-9])[A-Za-z_0-9]*\"),\n      Entity: tokens.filter((t) => t.name === \"Entity\")[0].PATTERN,\n      StaticSymbol: new RegExp(Esc.STATIC + \"[A-Za-z_0-9][A-Za-z_0-9]*\"),\n      Special: new RegExp(`[${Esc.SPECIAL.replace(\"&\", \"\")}]`),\n      Continue: new RegExp(Esc.CONTINUATION + \"\\\\r?\\\\n\", \"g\"),\n      Whitespace: /[\\u00a0\\u2000-\\u200b\\u2028-\\u2029\\u3000]+/g\n    };\n  }\n  /** @private */\n  _createTransforms() {\n    let transforms = {\n      quotify: (w) => _RiScript.quotify(w),\n      pluralize: (w) => _RiScript.pluralize(w, this.RiTa),\n      articlize: (w) => _RiScript.articlize(w, this.RiTa),\n      capitalize: (w) => _RiScript.capitalize(w),\n      uppercase: (w) => _RiScript.uppercase(w),\n      norepeat: (w) => _RiScript.identity(w)\n    };\n    transforms.art = transforms.articlize;\n    transforms.nr = transforms.norepeat;\n    transforms.cap = transforms.capitalize;\n    transforms.uc = transforms.uppercase;\n    transforms.qq = transforms.quotify;\n    transforms.s = transforms.pluralize;\n    transforms.ucf = transforms.capitalize;\n    return transforms;\n  }\n};\n/** @type {string} */\n__publicField(_RiScript, \"VERSION\", \"1.1.1\");\n/** @type {typeof RiQuery} */\n__publicField(_RiScript, \"Query\", RiQuery);\n/** @type {Object.<string, boolean>} */\n__publicField(_RiScript, \"RiTaWarnings\", { plurals: false, phones: false, silent: false });\nvar RiScript = _RiScript;\nfunction charCount(str, c) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === c)\n      count++;\n  }\n  return count;\n}\nRiScript.Visitor = RiScriptVisitor;\nRiScript.Util = Util;\n\n//# sourceMappingURL=riscript.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmlzY3JpcHQvZGlzdC9yaXNjcmlwdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvQjtBQUNVO0FBQ0s7O0FBRW5DO0FBQ3VDO0FBQ3ZDLG1DQUFtQyxpREFBUztBQUM1QztBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQyxZQUFZO0FBQ1o7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0NBQXdDLGlDQUFpQztBQUN6RSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFB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Y3JpcHQvZGlzdC9yaXNjcmlwdC5qcz8yOTAzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gc3JjL3Jpc2NyaXB0LmpzXG5pbXBvcnQgaGUgZnJvbSBcImhlXCI7XG5pbXBvcnQgeyBRdWVyeSB9IGZyb20gXCJtaW5nb1wiO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiY2hldnJvdGFpblwiO1xuXG4vLyBzcmMvcGFyc2VyLmpzXG5pbXBvcnQgeyBDc3RQYXJzZXIgfSBmcm9tIFwiY2hldnJvdGFpblwiO1xudmFyIFJpU2NyaXB0UGFyc2VyID0gY2xhc3MgZXh0ZW5kcyBDc3RQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihhbGxUb2tlbnMsIHRleHRUeXBlcykge1xuICAgIHN1cGVyKGFsbFRva2VucywgeyBub2RlTG9jYXRpb25UcmFja2luZzogXCJmdWxsXCIgfSk7XG4gICAgdGhpcy5hdG9tVHlwZXMgPSBbXCJzaWxlbnRcIiwgXCJhc3NpZ25cIiwgXCJzeW1ib2xcIiwgXCJjaG9pY2VcIiwgXCJwZ2F0ZVwiLCBcInRleHRcIiwgXCJlbnRpdHlcIl07XG4gICAgdGhpcy50ZXh0VHlwZXMgPSB0ZXh0VHlwZXM7XG4gICAgdGhpcy5idWlsZFJ1bGVzKCk7XG4gIH1cbiAgcGFyc2Uob3B0cykge1xuICAgIHRoaXMuaW5wdXQgPSBvcHRzLnRva2VucztcbiAgICBsZXQgY3N0ID0gdGhpcy5zY3JpcHQoKTtcbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMClcbiAgICAgIHRocm93IEVycm9yKFwiW1BBUlNJTkddXFxuXCIgKyB0aGlzLmVycm9yc1swXS5tZXNzYWdlKTtcbiAgICByZXR1cm4gY3N0O1xuICB9XG4gIC8qXG4gICAgU3BlY2lmaWNhdGlvbjpcbiAgICAgIHNjcmlwdDogZXhwcitcbiAgICAgIGV4cHI6IGF0b20rXG4gICAgICBhdG9tOiAoY2hvaWNlIHwgc3ltYm9sIHwgdGV4dCB8IHNpbGVudCB8IGVudGl0eSB8IHBnYXRlIHwgYXNzaWduKVxuICAgICAgd2V4cHI6IChleHByIHwgV2VpZ2h0KSpcbiAgICAgIHN5bWJvbDogU3ltYm9sIHRyYW5zZm9ybSpcbiAgICAgIGNob2ljZTogWyBnYXRlPyBvckV4cHIgZWxzZUV4cHI/IF0gdHJhbnNmb3JtKlxuICAgICAgYXNzaWduOiBTeW1ib2wgRVEgZXhwclxuICAgICAgc2lsZW50OiB7IGdhdGU/IChzeW1ib2wgfCBhc3NpZ24pIH1cbiAgICAgIG9yRXhwcjogd2V4cHIgKE9SIHdleHByKSpcbiAgICAgIGVsc2VFeHByOiBFTFNFIG9yRXhwclxuICAgICAgcGdhdGU6IFBHYXRlXG4gICAgICBlbnRpdHk6IEVudGl0eVxuICAgICAgZ2F0ZTogTWluZ29cbiAgICAgIHRleHQ6IFJhdyB8IFNUQVQgfCBBTVAgXG4gICovXG4gIGJ1aWxkUnVsZXMoKSB7XG4gICAgY29uc3QgJCA9IHRoaXMsIFRva2VucyA9IHRoaXMudG9rZW5zTWFwO1xuICAgICQuUlVMRShcInNjcmlwdFwiLCAoKSA9PiB7XG4gICAgICAkLk1BTlkoKCkgPT4gJC5TVUJSVUxFKCQuZXhwcikpO1xuICAgIH0pO1xuICAgICQuUlVMRShcImV4cHJcIiwgKCkgPT4ge1xuICAgICAgJC5BVF9MRUFTVF9PTkUoKCkgPT4gJC5TVUJSVUxFKCQuYXRvbSkpO1xuICAgIH0pO1xuICAgICQuUlVMRShcImF0b21cIiwgKCkgPT4ge1xuICAgICAgJC5PUih0aGlzLmF0b21UeXBlcy5tYXAoKHQpID0+ICh7IEFMVDogKCkgPT4gJC5TVUJSVUxFKCRbdF0pIH0pKSk7XG4gICAgfSk7XG4gICAgJC5SVUxFKFwid2V4cHJcIiwgKCkgPT4ge1xuICAgICAgJC5NQU5ZKCgpID0+IHtcbiAgICAgICAgJC5PUihbXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuU1VCUlVMRSgkLmV4cHIpIH0sXG4gICAgICAgICAgeyBBTFQ6ICgpID0+ICQuQ09OU1VNRShUb2tlbnMuV2VpZ2h0KSB9XG4gICAgICAgIF0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJC5SVUxFKFwic3ltYm9sXCIsICgpID0+IHtcbiAgICAgICQuQ09OU1VNRShUb2tlbnMuU3ltYm9sKTtcbiAgICAgICQuTUFOWSgoKSA9PiAkLkNPTlNVTUUoVG9rZW5zLlRyYW5zZm9ybSkpO1xuICAgIH0pO1xuICAgICQuUlVMRShcImNob2ljZVwiLCAoKSA9PiB7XG4gICAgICAkLkNPTlNVTUUoVG9rZW5zLk9DKTtcbiAgICAgICQuT1BUSU9OMSgoKSA9PiAkLlNVQlJVTEUoJC5nYXRlKSk7XG4gICAgICAkLlNVQlJVTEUoJC5vckV4cHIpO1xuICAgICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICAgJC5TVUJSVUxFMigkLmVsc2VFeHByKTtcbiAgICAgIH0pO1xuICAgICAgJC5DT05TVU1FKFRva2Vucy5DQyk7XG4gICAgICAkLk1BTlkoKCkgPT4gJC5DT05TVU1FKFRva2Vucy5UcmFuc2Zvcm0pKTtcbiAgICB9KTtcbiAgICAkLlJVTEUoXCJhc3NpZ25cIiwgKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKFRva2Vucy5TeW1ib2wpO1xuICAgICAgJC5DT05TVU1FKFRva2Vucy5FUSk7XG4gICAgICAkLlNVQlJVTEUoJC5leHByKTtcbiAgICB9KTtcbiAgICAkLlJVTEUoXCJzaWxlbnRcIiwgKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKFRva2Vucy5PUyk7XG4gICAgICAkLk9QVElPTjEoKCkgPT4gJC5TVUJSVUxFKCQuZ2F0ZSkpO1xuICAgICAgJC5DT05TVU1FKFRva2Vucy5TeW1ib2wpO1xuICAgICAgJC5PUFRJT04yKCgpID0+IHtcbiAgICAgICAgJC5DT05TVU1FKFRva2Vucy5FUSk7XG4gICAgICAgICQuU1VCUlVMRSgkLmV4cHIpO1xuICAgICAgfSk7XG4gICAgICAkLkNPTlNVTUUoVG9rZW5zLkNTKTtcbiAgICB9KTtcbiAgICAkLlJVTEUoXCJvckV4cHJcIiwgKCkgPT4ge1xuICAgICAgJC5NQU5ZX1NFUCh7XG4gICAgICAgIFNFUDogVG9rZW5zLk9SLFxuICAgICAgICBERUY6ICgpID0+ICQuU1VCUlVMRSgkLndleHByKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgJC5SVUxFKFwiZWxzZUV4cHJcIiwgKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKFRva2Vucy5FTFNFKTtcbiAgICAgICQuU1VCUlVMRSgkLm9yRXhwcik7XG4gICAgfSk7XG4gICAgJC5SVUxFKFwicGdhdGVcIiwgKCkgPT4ge1xuICAgICAgJC5DT05TVU1FKFRva2Vucy5QZW5kaW5nR2F0ZSk7XG4gICAgfSk7XG4gICAgJC5SVUxFKFwiZW50aXR5XCIsICgpID0+IHtcbiAgICAgICQuQ09OU1VNRShUb2tlbnMuRW50aXR5KTtcbiAgICB9KTtcbiAgICAkLlJVTEUoXCJnYXRlXCIsICgpID0+IHtcbiAgICAgICQuTUFOWSgoKSA9PiAkLkNPTlNVTUUoVG9rZW5zLkdhdGUpKTtcbiAgICB9KTtcbiAgICAkLlJVTEUoXCJ0ZXh0XCIsICgpID0+IHtcbiAgICAgICQuT1IodGhpcy50ZXh0VHlwZXMubWFwKCh0KSA9PiAoeyBBTFQ6ICgpID0+ICQuQ09OU1VNRShUb2tlbnNbdF0pIH0pKSk7XG4gICAgfSk7XG4gICAgdGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsLmpzXG52YXIgX1V0aWwgPSBjbGFzcyBfVXRpbCB7XG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gRlVOQ1RJT05TIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgc3RhdGljIGZvcm1hdEFueShvKSB7XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGAnJHtvfSdgO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBvID09PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIG87XG4gICAgaWYgKHR5cGVvZiBvID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBFcnJvcihcInVuZXhwZWN0ZWQgZnVuY3Rpb25cIik7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG8pLnJlcGxhY2UoL1wiL2csIFwiXCIpO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm1OYW1lcyh0eHMpIHtcbiAgICByZXR1cm4gdHhzICYmIHR4cy5sZW5ndGggPyB0eHMubWFwKCh0eCkgPT4gdHguaW1hZ2UucmVwbGFjZSgvKF5cXC58XFwoXFwpJCkvZywgXCJcIiksIFtdKSA6IFtdO1xuICB9XG4gIHN0YXRpYyBlc2NhcGVUZXh0KHMsIHF1b3RpZnkpIHtcbiAgICBpZiAodHlwZW9mIHMgIT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gX1V0aWwuZm9ybWF0QW55KHMpO1xuICAgIGxldCB0ID0gcy5yZXBsYWNlKC9cXHI/XFxuL2csIFwiXFxcXG5cIik7XG4gICAgcmV0dXJuIHF1b3RpZnkgfHwgIXQubGVuZ3RoID8gXCInXCIgKyB0ICsgXCInXCIgOiB0O1xuICB9XG4gIHN0YXRpYyBzdHJpbmdIYXNoKHMpIHtcbiAgICBsZXQgY2hyLCBoYXNoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNociA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgICBoYXNoIHw9IDA7XG4gICAgfVxuICAgIGxldCBzdHJIYXNoID0gaGFzaC50b1N0cmluZygpLnBhZFN0YXJ0KDksIFwiMFwiKTtcbiAgICByZXR1cm4gaGFzaCA8IDAgPyBzdHJIYXNoLnJlcGxhY2UoXCItXCIsIFwiMFwiKSA6IHN0ckhhc2g7XG4gIH1cbiAgc3RhdGljIGVzY2FwZU1hcmtkb3duTGluayh0eHQpIHtcbiAgICBsZXQgcmVzdWx0ID0gdHh0O1xuICAgIGxldCBsb29rdXBzID0geyBcIltcIjogXCImbHNxYjtcIiwgXCJdXCI6IFwiJnJzcWI7XCIsIFwiKFwiOiBcIiZscGFyO1wiLCBcIilcIjogXCImcnBhcjtcIiwgXCIvXCI6IFwiJnNvbDtcIiB9O1xuICAgIE9iamVjdC5lbnRyaWVzKGxvb2t1cHMpLmZvckVhY2goKFtrLCB2XSkgPT4gcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UobmV3IFJlZ0V4cChgXFxcXCR7a31gLCBcImdcIiksIHYpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyBzbGFzaEVzY1RvRW50aXRpZXMocykge1xuICAgIHMgPSBfVXRpbC5yZXBsYWNlQWxsKHMsIFwiXFxcXChcIiwgXCImbHBhcjtcIik7XG4gICAgcyA9IF9VdGlsLnJlcGxhY2VBbGwocywgXCJcXFxcKVwiLCBcIiZycGFyO1wiKTtcbiAgICBzID0gX1V0aWwucmVwbGFjZUFsbChzLCBcIlxcXFxbXCIsIFwiJmxzcWI7XCIpO1xuICAgIHMgPSBfVXRpbC5yZXBsYWNlQWxsKHMsIFwiXFxcXF1cIiwgXCImcnNxYjtcIik7XG4gICAgcyA9IF9VdGlsLnJlcGxhY2VBbGwocywgXCJcXFxce1wiLCBcIiZsY3FiO1wiKTtcbiAgICBzID0gX1V0aWwucmVwbGFjZUFsbChzLCBcIlxcXFx9XCIsIFwiJnJjcWI7XCIpO1xuICAgIHMgPSBfVXRpbC5yZXBsYWNlQWxsKHMsIFwiXFxcXEBcIiwgXCImY29tbWF0O1wiKTtcbiAgICBzID0gX1V0aWwucmVwbGFjZUFsbChzLCBcIlxcXFwjXCIsIFwiJm51bTtcIik7XG4gICAgcyA9IF9VdGlsLnJlcGxhY2VBbGwocywgXCJcXFxcfFwiLCBcIiAmdmVydFwiKTtcbiAgICBzID0gX1V0aWwucmVwbGFjZUFsbChzLCBcIlxcXFw9XCIsIFwiICZlcXVhbHNcIik7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgc3RhdGljIGVzY2FwZUpTT05SZWdleCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShcbiAgICAgIC9cXC8oW14vXSs/KVxcLyhbaWdtc3V5XSopL2csXG4gICAgICBgXCIke19VdGlsLlJlZ2V4RXNjYXBlfSQxJHtfVXRpbC5SZWdleEVzY2FwZX0kMiR7X1V0aWwuUmVnZXhFc2NhcGV9XCJgXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICB9XG4gIHN0YXRpYyByZXBsYWNlQWxsKHN0ciwgbWF0Y2gsIHJlcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoX1V0aWwuZXNjYXBlUmVnRXhwKG1hdGNoKSwgXCJnXCIpLCAoKSA9PiByZXBsYWNlbWVudCk7XG4gIH1cbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vIENPTlNUQU5UUyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBVdGlsXG4gKiBAcGFja2FnZVxuICovXG5fX3B1YmxpY0ZpZWxkKF9VdGlsLCBcIlJlZ2V4RXNjYXBlXCIsIFwiX1JFX1wiKTtcbnZhciBVdGlsID0gX1V0aWw7XG5cbi8vIHNyYy92aXNpdG9yLmpzXG52YXIgeyBlc2NhcGVUZXh0LCBzdHJpbmdIYXNoLCBmb3JtYXRBbnksIHRyYW5zZm9ybU5hbWVzIH0gPSBVdGlsO1xudmFyIEJhc2VWaXNpdG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihyaVNjcmlwdCkge1xuICAgIHRoaXMuaW5wdXQgPSBcIlwiO1xuICAgIHRoaXMubm93YXJuID0gZmFsc2U7XG4gICAgdGhpcy50cmFjZVBhdGggPSB0cnVlO1xuICAgIHRoaXMuc2NyaXB0aW5nID0gcmlTY3JpcHQ7XG4gICAgdGhpcy53YXJuT25JbnZhbGlkR2F0ZXMgPSBmYWxzZTtcbiAgICB0aGlzLm1heFJlY3Vyc2lvbkRlcHRoID0gMTA7XG4gIH1cbiAgdGV4dEZyb21Dc3ROb2RlKG5vZGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSlcbiAgICAgIG5vZGUgPSBub2RlWzBdO1xuICAgIHJldHVybiB0aGlzLmlucHV0LnN1YnN0cmluZyhcbiAgICAgIG5vZGUubG9jYXRpb24uc3RhcnRPZmZzZXQsXG4gICAgICBub2RlLmxvY2F0aW9uLmVuZE9mZnNldCArIDFcbiAgICApO1xuICB9XG4gIGlzQ3N0Tm9kZShvKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpXG4gICAgICBvID0gb1swXTtcbiAgICByZXR1cm4gdHlwZW9mIG8gPT09IFwib2JqZWN0XCIgJiYgKFwiYWNjZXB0XCIgaW4gbyB8fCBcIm5hbWVcIiBpbiBvICYmIFwibG9jYXRpb25cIiBpbiBvICYmIFwiY2hpbGRyZW5cIiBpbiBvKTtcbiAgfVxuICB2aXNpdChjc3ROb2RlLCBvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3N0Tm9kZSkpIHtcbiAgICAgIGNzdE5vZGUgPSBjc3ROb2RlWzBdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNzdE5vZGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0NzdE5vZGUoY3N0Tm9kZSkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiTm9uLWNzdE5vZGUgcGFzc2VkIHRvIHZpc2l0OiBcIiArIEpTT04uc3RyaW5naWZ5KGNzdE5vZGUpKTtcbiAgICB9XG4gICAgdGhpcy5ub2RlVGV4dCA9IHRoaXMudGV4dEZyb21Dc3ROb2RlKGNzdE5vZGUpO1xuICAgIGNvbnN0IG5hbWUgPSBjc3ROb2RlLm5hbWU7XG4gICAgaWYgKHR5cGVvZiB0aGlzW25hbWVdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IEVycm9yKGBCYXNlVmlzaXRvci52aXNpdDogZXhwZWN0aW5nIGZ1bmN0aW9uIGZvciB0aGlzWyR7bmFtZX1dLCBmb3VuZCAke3R5cGVvZiB0aGlzW25hbWVdfTogJHtKU09OLnN0cmluZ2lmeSh0aGlzW25hbWVdKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbbmFtZV0oY3N0Tm9kZS5jaGlsZHJlbiwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVWaXNpdG9yKCkge1xuICB9XG59O1xudmFyIFJpU2NyaXB0VmlzaXRvciA9IGNsYXNzIGV4dGVuZHMgQmFzZVZpc2l0b3Ige1xuICBjb25zdHJ1Y3RvcihyaVNjcmlwdCwgY29udGV4dCA9IHt9KSB7XG4gICAgc3VwZXIocmlTY3JpcHQpO1xuICAgIHRoaXMub3JkZXIgPSAwO1xuICAgIHRoaXMudHJhY2UgPSAwO1xuICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICB0aGlzLmNob2ljZXMgPSB7fTtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuaXNOb1JlcGVhdCA9IGZhbHNlO1xuICAgIHRoaXMuU3ltYm9scyA9IHRoaXMuc2NyaXB0aW5nLlN5bWJvbHM7XG4gICAgdGhpcy5Fc2NhcGVkID0gdGhpcy5zY3JpcHRpbmcuRXNjYXBlZDtcbiAgICB0aGlzLnN0YXRpY3MgPSB7fTtcbiAgICB0aGlzLmR5bmFtaWNzID0ge307XG4gICAgdGhpcy5wZW5kaW5nR2F0ZXMgPSB7fTtcbiAgICB0aGlzLnZhbGlkYXRlVmlzaXRvcigpO1xuICB9XG4gIHN0YXJ0KG9wdHMgPSB7fSkge1xuICAgIHRoaXMuaW5wdXQgPSBvcHRzLmlucHV0O1xuICAgIHRoaXMudHJhY2UgPSBvcHRzLnRyYWNlO1xuICAgIHRoaXMubm93YXJuID0gb3B0cy5zaWxlbnQ7XG4gICAgdGhpcy50cmFjZVR4ID0gb3B0cy50cmFjZVR4O1xuICAgIGlmICghb3B0cy5jc3QpXG4gICAgICB0aHJvdyBFcnJvcihcIm5vIGNzdFwiKTtcbiAgICByZXR1cm4gc3VwZXIudmlzaXQob3B0cy5jc3QpO1xuICB9XG4gIHNjcmlwdChjdHgpIHtcbiAgICB0aGlzLm9yZGVyID0gdGhpcy5pbmRlbnQgPSAwO1xuICAgIGlmIChPYmplY3Qua2V5cyhjdHgpLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93IEVycm9yKFwic2NyaXB0OiBpbnZhbGlkIGV4cHJcIik7XG4gICAgbGV0IGNvdW50ID0gY3R4LmV4cHJbMF0uY2hpbGRyZW4uYXRvbS5sZW5ndGg7XG4gICAgdGhpcy5wcmludChcInNjcmlwdFwiLCBgJyR7ZXNjYXBlVGV4dCh0aGlzLmlucHV0KX0nIDo6ICR7Y291bnR9IGF0b20ocylgKTtcbiAgICBpZiAoIWNvdW50KVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgdGhpcy5pbmRlbnQrKztcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnZpc2l0KGN0eC5leHByKTtcbiAgICB0aGlzLmluZGVudC0tO1xuICAgIHRoaXMucHJpbnQoXCIvc2NyaXB0XCIpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBleHByKGN0eCkge1xuICAgIGNvbnN0IHR5cGVzID0gT2JqZWN0LmtleXMoY3R4KTtcbiAgICBpZiAodHlwZXMubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIGV4cHI6IFwiICsgdHlwZXMubGVuZ3RoKTtcbiAgICBjb25zdCBleHBycyA9IGN0eC5hdG9tLm1hcCgoYykgPT4gdGhpcy52aXNpdChjKSk7XG4gICAgaWYgKGV4cHJzLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybiBleHByc1swXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGV4cHJzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgaWYgKGV4cHJzW2ldLmxlbmd0aCA9PT0gMCAmJiBleHByc1tpIC0gMV0uZW5kc1dpdGgoXCIgXCIpICYmIGV4cHJzW2kgKyAxXS5zdGFydHNXaXRoKFwiIFwiKSkge1xuICAgICAgICBleHByc1tpICsgMV0gPSBleHByc1tpICsgMV0uc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcnMuam9pbihcIlwiKTtcbiAgfVxuICBhdG9tKGN0eCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyhjdHgpO1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgYXRvbTogXCIgKyB0eXBlcyk7XG4gICAgdGhpcy5zY3JpcHRpbmcucGFyc2VyLmF0b21UeXBlcy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICBpZiAoY3R4W3R5cGVdKSB7XG4gICAgICAgIGlmIChjdHhbdHlwZV0ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IodHlwZSArIFwiOiBiYWQgbGVuZ3RoIC0+IFwiICsgY3R4W3R5cGVdLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy52aXNpdChjdHhbdHlwZV1bMF0pO1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNhbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgc2lsZW50KGN0eCkge1xuICAgIHRoaXMucHJpbnQoXCJzaWxlbnRcIiwgdGhpcy5ub2RlVGV4dCk7XG4gICAgdGhpcy5pbmRlbnQrKztcbiAgICBpZiAoY3R4LkVRKSB7XG4gICAgICB0aGlzLmFzc2lnbihjdHgsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN5bWJvbChjdHgsIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgIH1cbiAgICB0aGlzLmluZGVudC0tO1xuICAgIHRoaXMucHJpbnQoXCIvc2lsZW50XCIsIFwic3RhdGljcz1cIiArIGZvcm1hdEFueSh0aGlzLnN0YXRpY3MpKTtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuICBhc3NpZ24oY3R4LCBvcHRzKSB7XG4gICAgY29uc3Qgc3ltID0gY3R4LlN5bWJvbFswXS5pbWFnZTtcbiAgICBjb25zdCBvcmlnaW5hbCA9IHRoaXMubm9kZVRleHQ7XG4gICAgY29uc3QgaWRlbnQgPSBzeW0ucmVwbGFjZSh0aGlzLnNjcmlwdGluZy5yZWdleC5BbnlTeW1ib2wsIFwiXCIpO1xuICAgIGNvbnN0IGlzU3RhdGljID0gc3ltLnN0YXJ0c1dpdGgodGhpcy5TeW1ib2xzLlNUQVRJQyk7XG4gICAgY29uc3QgaXNTaWxlbnQgPSBvcHRzPy5zaWxlbnQ7XG4gICAgbGV0IGluZm8gPSBgJHtvcmlnaW5hbH0gJHtpc1N0YXRpYyAmJiBpc1NpbGVudCA/IFwieyNzdGF0aWMsc2lsZW50fVwiIDogKGlzU3RhdGljID8gXCJ7I3N0YXRpY31cIiA6IFwiXCIpICsgKGlzU2lsZW50ID8gXCJ7c2lsZW50fVwiIDogXCJcIil9YDtcbiAgICB0aGlzLnByaW50KFwiYXNzaWduXCIsIGluZm8pO1xuICAgIGxldCB2YWx1ZTtcbiAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgIGlmIChpZGVudCBpbiB0aGlzLnN0YXRpY3MgJiYgIXRoaXMuc2NyaXB0aW5nLmlzUGFyc2VhYmxlKHRoaXMuc3RhdGljc1tpZGVudF0pKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5zdGF0aWNzW2lkZW50XTtcbiAgICAgICAgaW5mbyA9IGAke3N5bX0gPSAke2Zvcm1hdEFueSh2YWx1ZSl9IHsjcmVzb2x2ZWR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5kZW50Kys7XG4gICAgICAgIHZhbHVlID0gdGhpcy52aXNpdChjdHguZXhwcik7XG4gICAgICAgIHRoaXMuaW5kZW50LS07XG4gICAgICAgIHRoaXMuc3RhdGljc1tpZGVudF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB0aGlzLnNjcmlwdGluZy5pc1BhcnNlYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuaW5saW5lU3RhdGljQXNzaWduKGlkZW50LCBjdHguVHJhbnNmb3JtLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5mbyA9IGAke3N5bX0gPSAke2Zvcm1hdEFueSh2YWx1ZSl9YDtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpbnQoXCIvYXNzaWduXCIsIGluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCAkID0gdGhpcztcbiAgICAgIHRoaXMuaW5kZW50Kys7XG4gICAgICB2YWx1ZSA9ICgpID0+ICQudmlzaXQoY3R4LmV4cHIpO1xuICAgICAgdGhpcy5pbmRlbnQtLTtcbiAgICAgIHRoaXMuZHluYW1pY3NbaWRlbnRdID0gdmFsdWU7XG4gICAgICB0aGlzLnByaW50KFwiL2Fzc2lnblwiLCBgJHtzeW19ID0gIDxmKjpwZW5kaW5nPmApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLy8gZW5kIGFzc2lnblxuICBzeW1ib2woY3R4LCBvcHRzKSB7XG4gICAgaWYgKGN0eC5TeW1ib2wubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgRXJyb3IoXCJbMV0gaW52YWxpZCBzeW1ib2xcIik7XG4gICAgY29uc3QgaXNTaWxlbnQgPSBvcHRzPy5zaWxlbnQ7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSB0aGlzLm5vZGVUZXh0O1xuICAgIGNvbnN0IHN5bSA9IGN0eC5TeW1ib2xbMF0uaW1hZ2UucmVwbGFjZSgvXFwoXFwpJC8sIFwiXCIpO1xuICAgIGNvbnN0IGlkZW50ID0gc3ltLnJlcGxhY2UodGhpcy5zY3JpcHRpbmcucmVnZXguQW55U3ltYm9sLCBcIlwiKTtcbiAgICB0aGlzLmlzTm9SZXBlYXQgPSB0aGlzLmhhc05vUmVwZWF0KGN0eC5UcmFuc2Zvcm0pO1xuICAgIHRoaXMucHJpbnQoXCJzeW1ib2xcIiwgYCR7b3JpZ2luYWx9ICR7aXNTaWxlbnQgPyBcIiB7c2lsZW50fVwiIDogXCJcIn1gKTtcbiAgICBsZXQgeyByZXN1bHQsIGlzU3RhdGljLCBpc1VzZXIsIHJlc29sdmVkIH0gPSB0aGlzLmNoZWNrQ29udGV4dChpZGVudCk7XG4gICAgaWYgKCFpc1N0YXRpYyAmJiB0aGlzLnNjcmlwdGluZy5yZWdleC5TdGF0aWNTeW1ib2wudGVzdChzeW0pKSB7XG4gICAgICBpZiAoIXRoaXMuc2NyaXB0aW5nLnJlZ2V4LkVudGl0eS50ZXN0KHN5bSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYEF0dGVtcHQgdG8gcmVmZXIgdG8gZHluYW1pYyBzeW1ib2wgJyR7aWRlbnR9JyBhcyAke3RoaXMuU3ltYm9scy5TVEFUSUN9JHtpZGVudH0sIGRpZCB5b3UgbWVhbiAkJHtpZGVudH0/YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyB0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCI7IGkrKykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LmNhbGwoKTtcbiAgICAgIHJlc29sdmVkID0gIXRoaXMuc2NyaXB0aW5nLmlzUGFyc2VhYmxlKHJlc3VsdCk7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5tYXhSZWN1cnNpb25EZXB0aClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJNYXggcmVjdXJzaW9uIGRlcHRoIHJlYWNoZWRcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTm9SZXBlYXQgJiYgKGlzU3RhdGljIHx8IGlzVXNlcikpIHtcbiAgICAgIHRoaXMuaXNOb1JlcGVhdCA9IGZhbHNlO1xuICAgICAgY29uc3QgbXNnID0gXCJBdHRlbXB0IHRvIGNhbGwgbm9yZXBlYXQoKSBvbiBcIiArIChpc1N0YXRpYyA/IFwic3RhdGljIHN5bWJvbCAnXCIgKyBzeW0gKyBcIicuIERpZCB5b3UgbWVhbiB0byB1c2UgJ1wiICsgdGhpcy5TeW1ib2xzLkRZTkFNSUMgKyBpZGVudCArIFwiJyA/XCIgOiBcIm5vbi1keW5hbWljIHN5bWJvbCAnXCIgKyBpZGVudCArIFwiJy4gRGlkIHlvdSBtZWFuIHRvIGRlZmluZSAnXCIgKyB0aGlzLlN5bWJvbHMuRFlOQU1JQyArIGlkZW50ICsgXCInIGluIHJpc2NyaXB0P1wiKTtcbiAgICAgIHRocm93IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnByaW50KFwiL3N5bWJvbFwiLCBzeW0gKyBcIiAtPiAnXCIgKyBvcmlnaW5hbCArIFwiJyBjdHg9XCIgKyB0aGlzLmxvb2t1cHNUb1N0cmluZygpLCBcIltkZWZlcnJlZF1cIiwgb3B0cz8uc2lsZW50ID8gXCJ7c2lsZW50fVwiIDogXCJcIik7XG4gICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgfVxuICAgIGxldCBpbmZvID0gb3B0cz8udHJhY2UgPyBgJHtvcmlnaW5hbC5yZXBsYWNlKC9cXChcXCkkLywgXCJcIil9IC0+ICR7Zm9ybWF0QW55KHJlc3VsdCl9YCArIChvcHRzPy5zaWxlbnQgPyBcIiB7c2lsZW50fVwiIDogXCJcIikgOiBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiICYmICFyZXNvbHZlZCkge1xuICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuaW5saW5lU3RhdGljQXNzaWduKGlkZW50LCBjdHguVHJhbnNmb3JtLCByZXN1bHQpO1xuICAgICAgICB0aGlzLnByaW50KFwiL3N5bWJvbFwiLCBgJHtvcmlnaW5hbH0gLT4gJHtyZXN1bHR9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3R4LlRyYW5zZm9ybSlcbiAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3RvcmVUcmFuc2Zvcm1zKHJlc3VsdCwgY3R4LlRyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMucHJpbnQoXCIvc3ltYm9sXCIsIGluZm8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGlzU3RhdGljKVxuICAgICAgdGhpcy5zdGF0aWNzW2lkZW50XSA9IHJlc3VsdDtcbiAgICBpZiAoY3R4LlRyYW5zZm9ybSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseVRyYW5zZm9ybXMocmVzdWx0LCBjdHguVHJhbnNmb3JtKTtcbiAgICAgIGluZm8gKz0gXCItPiAnXCIgKyByZXN1bHQgKyBcIidcIjtcbiAgICAgIGlmICh0aGlzLmlzTm9SZXBlYXQpXG4gICAgICAgIGluZm8gKz0gXCIgKG5vcmVwZWF0KVwiO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCAmJiBzeW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBzeW07XG4gICAgICBpbmZvID0gXCIqKiAkICoqXCI7XG4gICAgfVxuICAgIHRoaXMucHJpbnQoXCIvc3ltYm9sXCIsIGluZm8pO1xuICAgIHRoaXMuaXNOb1JlcGVhdCA9IGZhbHNlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gZW5kIHN5bWJvbFxuICBjaG9pY2UoY3R4LCBvcHRzKSB7XG4gICAgY29uc3QgJCA9IHRoaXMuU3ltYm9scztcbiAgICBjb25zdCBvcmlnaW5hbCA9IHRoaXMubm9kZVRleHQ7XG4gICAgY29uc3QgY2hvaWNlS2V5ID0gc3RyaW5nSGFzaChvcmlnaW5hbCArIFwiICNcIiArIHRoaXMuY2hvaWNlSWQoY3R4KSk7XG4gICAgbGV0IGdhdGVUZXh0LCBnYXRlUmVzdWx0LCBoYXNUcmFuc2Zvcm1zID0gY3R4LlRyYW5zZm9ybTtcbiAgICBpZiAoIXRoaXMuaXNOb1JlcGVhdCAmJiB0aGlzLmhhc05vUmVwZWF0KGN0eC5UcmFuc2Zvcm0pKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIm5vUmVwZWF0KCkgbm90IGFsbG93ZWQgb24gY2hvaWNlICh1c2UgYSAkdmFyaWFibGUgaW5zdGVhZCk6IFwiICsgb3JpZ2luYWwpO1xuICAgIH1cbiAgICB0aGlzLnByaW50KFwiY2hvaWNlXCIsIG9yaWdpbmFsKTtcbiAgICBsZXQgZGVjaXNpb24gPSBcImFjY2VwdFwiO1xuICAgIGlmIChvcHRzPy5mb3JjZVJlamVjdCkge1xuICAgICAgZGVjaXNpb24gPSBcInJlamVjdFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZ2F0ZUN0eCA9IGN0eD8uZ2F0ZT8uWzBdPy5jaGlsZHJlbj8uR2F0ZTtcbiAgICAgIGlmIChnYXRlQ3R4KSB7XG4gICAgICAgIGdhdGVUZXh0ID0gZ2F0ZUN0eFswXS5pbWFnZTtcbiAgICAgICAgdGhpcy5pbmRlbnQrKztcbiAgICAgICAgZ2F0ZVJlc3VsdCA9IHRoaXMudmlzaXQoY3R4LmdhdGUpO1xuICAgICAgICB0aGlzLmluZGVudC0tO1xuICAgICAgICBkZWNpc2lvbiA9IGdhdGVSZXN1bHQuZGVjaXNpb247XG4gICAgICAgIGxldCBnaW5mbyA9IGAke2dhdGVUZXh0fSAtPiAke2RlY2lzaW9uICE9PSBcImRlZmVyXCIgPyBkZWNpc2lvbi50b1VwcGVyQ2FzZSgpIDogYERFRkVSICR7JC5QRU5ESU5HX0dBVEV9JHtjaG9pY2VLZXl9YH0gICR7dGhpcy5sb29rdXBzVG9TdHJpbmcoKX1gO1xuICAgICAgICB0aGlzLnByaW50KFwiZ2F0ZVwiLCBnaW5mbyk7XG4gICAgICB9XG4gICAgICBpZiAoZ2F0ZVJlc3VsdCAmJiBnYXRlUmVzdWx0LmRlY2lzaW9uID09PSBcImRlZmVyXCIpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nR2F0ZXNbY2hvaWNlS2V5XSA9IHtcbiAgICAgICAgICBnYXRlVGV4dCxcbiAgICAgICAgICBkZWZlcnJlZENvbnRleHQ6IGN0eCxcbiAgICAgICAgICBvcGVyYW5kczogZ2F0ZVJlc3VsdC5vcGVyYW5kc1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYCR7JC5QRU5ESU5HX0dBVEV9JHtjaG9pY2VLZXl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG9yRXhwciA9IGN0eD8ub3JFeHByWzBdO1xuICAgIGlmIChkZWNpc2lvbiA9PT0gXCJyZWplY3RcIikge1xuICAgICAgaWYgKCEoXCJlbHNlRXhwclwiIGluIGN0eCkpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgb3JFeHByID0gY3R4LmVsc2VFeHByWzBdLmNoaWxkcmVuLm9yRXhwclswXTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucGFyc2VPcHRpb25zKG9yRXhwcik7XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgdGhyb3cgRXJyb3IoXCJObyBvcHRpb25zIGluIGNob2ljZTogXCIgKyBvcmlnaW5hbCk7XG4gICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICBjb25zdCBleGNsdWRlZCA9IFtdO1xuICAgIGxldCByZXN0b3JlZCA9IGZhbHNlO1xuICAgIHdoaWxlICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSB0aGlzLmNob29zZShvcHRpb25zLCBleGNsdWRlZCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgdGhpcy5pc0NzdE5vZGUodmFsdWUpOyBpKyspIHtcbiAgICAgICAgdGhpcy5pbmRlbnQrKztcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZpc2l0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbmRlbnQtLTtcbiAgICAgICAgaWYgKGkgPT09IHRoaXMubWF4UmVjdXJzaW9uRGVwdGgpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJNYXggcmVjdXJzaW9uIGRlcHRoIHJlYWNoZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGN0eC5UcmFuc2Zvcm0pXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh2YWx1ZSwgY3R4LlRyYW5zZm9ybSk7XG4gICAgICAgIGhhc1RyYW5zZm9ybXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNjcmlwdGluZy5pc1BhcnNlYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGN0eC5UcmFuc2Zvcm0pXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLnJlc3RvcmVUcmFuc2Zvcm1zKHZhbHVlLCBjdHguVHJhbnNmb3JtKTtcbiAgICAgICAgcmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoYXNUcmFuc2Zvcm1zKVxuICAgICAgICB2YWx1ZSA9IHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHZhbHVlLCBjdHguVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLmlzTm9SZXBlYXQgJiYgdmFsdWUgPT09IHRoaXMuY2hvaWNlc1tjaG9pY2VLZXldKSB7XG4gICAgICAgIHRoaXMucHJpbnQoXCJjaG9pY2UtcmVqZWN0XCIsIHZhbHVlICsgXCIgW25vcmVwZWF0XVwiKTtcbiAgICAgICAgZXhjbHVkZWQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzdG9yZWQpXG4gICAgICB0aGlzLmNob2ljZXNbY2hvaWNlS2V5XSA9IHZhbHVlO1xuICAgIHRoaXMucHJpbnQoXCJjaG9pY2UvXCIsIG9yaWdpbmFsICsgXCIgLT4gJ1wiICsgdmFsdWUgKyBcIidcIik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIC8vIGVuZCBjaG9pY2VcbiAgY2hvb3NlKG9wdGlvbnMsIGV4Y2x1ZGVzID0gW10pIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgY2hvaWNlOiBubyBvcHRpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IG9wdGlvbnMuZmlsdGVyKCh4KSA9PiAhZXhjbHVkZXMuaW5jbHVkZXMoeCkpO1xuICAgIGlmICghdmFsaWQubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgY2hvaWNlOiBubyB2YWxpZCBvcHRpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc2NyaXB0aW5nLlJpVGEucmFuZGkodmFsaWQubGVuZ3RoKTtcbiAgICBsZXQgdmFsdWUgPSB2YWxpZFtpbmRleF07XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRleHQoY3R4KSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKGN0eCkubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgRXJyb3IoXCJbMl0gaW52YWxpZCB0ZXh0XCIpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnNjcmlwdGluZy50ZXh0VHlwZXMuZmlsdGVyKCh0KSA9PiBjdHhbdF0pO1xuICAgIGNvbnN0IGltYWdlID0gY3R4W3R5cGVdWzBdLmltYWdlO1xuICAgIHRoaXMucHJpbnQoXCJ0ZXh0L1wiLCBlc2NhcGVUZXh0KFwiJ1wiICsgaW1hZ2UgKyBcIidcIikpO1xuICAgIHJldHVybiBpbWFnZTtcbiAgfVxuICBlbnRpdHkoY3R4KSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVRleHQ7XG4gIH1cbiAgZ2F0ZShjdHgpIHtcbiAgICBpZiAoY3R4LkdhdGUubGVuZ3RoICE9PSAxKVxuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGdhdGU6IFwiICsgY3R4LkdhdGUpO1xuICAgIGxldCByYXcgPSBjdHguR2F0ZVswXS5pbWFnZSwgbWluZ29RdWVyeTtcbiAgICBpZiAocmF3LnN0YXJ0c1dpdGgodGhpcy5TeW1ib2xzLk9QRU5fR0FURSkpIHtcbiAgICAgIHJhdyA9IHJhdy5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBtaW5nb1F1ZXJ5ID0gdGhpcy5zY3JpcHRpbmcuY3JlYXRlUXVlcnkocmF3KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIXRoaXMud2Fybk9uSW52YWxpZEdhdGVzKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIGdhdGVbMl06IFwiQCR7cmF3fVwiXG5cblJvb3RDYXVzZSAtPiAke2V9YCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2NyaXB0aW5nLlJpVGEuU0lMRU5UICYmICF0aGlzLm5vd2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtXQVJOXSBJZ25vcmluZyBpbnZhbGlkIGdhdGU6IEAke3Jhd31AXG5gLCBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRlY2lzaW9uOiBcImFjY2VwdFwiIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkT3BzID0ge307XG4gICAgY29uc3QgdW5yZXNvbHZlZE9wcyA9IFtdO1xuICAgIGNvbnN0IG9wZXJhbmRzID0gbWluZ29RdWVyeS5vcGVyYW5kcygpO1xuICAgIG9wZXJhbmRzLmZvckVhY2goKHN5bSkgPT4ge1xuICAgICAgbGV0IHsgcmVzdWx0OiByZXN1bHQyLCByZXNvbHZlZCwgaXNTdGF0aWMsIGlzVXNlciB9ID0gdGhpcy5jaGVja0NvbnRleHQoc3ltKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyB0eXBlb2YgcmVzdWx0MiA9PT0gXCJmdW5jdGlvblwiOyBpKyspIHtcbiAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIuY2FsbCgpO1xuICAgICAgICByZXNvbHZlZCA9ICF0aGlzLnNjcmlwdGluZy5pc1BhcnNlYWJsZShyZXN1bHQyKTtcbiAgICAgICAgaWYgKGkgPT09IHRoaXMubWF4UmVjdXJzaW9uRGVwdGgpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJNYXggcmVjdXJzaW9uIGRlcHRoIHJlYWNoZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdDIgPT09IFwidW5kZWZpbmVkXCIgfHwgIXJlc29sdmVkKSB7XG4gICAgICAgIHVucmVzb2x2ZWRPcHMucHVzaChzeW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzU3RhdGljKSB7XG4gICAgICAgICAgdGhpcy5zdGF0aWNzW3N5bV0gPSByZXN1bHQyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVXNlcikge1xuICAgICAgICAgIHRoaXMuY29udGV4dFtzeW1dID0gcmVzdWx0MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmR5bmFtaWNzW3N5bV0gPSByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkT3BzW3N5bV0gPSByZXN1bHQyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChPYmplY3Qua2V5cyhyZXNvbHZlZE9wcykubGVuZ3RoICsgdW5yZXNvbHZlZE9wcy5sZW5ndGggIT09IG9wZXJhbmRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIG9wZXJhbmRzXCIpO1xuICAgIH1cbiAgICBpZiAodW5yZXNvbHZlZE9wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IGRlY2lzaW9uOiBcImRlZmVyXCIsIG9wZXJhbmRzOiB1bnJlc29sdmVkT3BzIH07XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBtaW5nb1F1ZXJ5LnRlc3QocmVzb2x2ZWRPcHMpO1xuICAgIGlmICghcmVzdWx0ICYmIHRoaXMuY2FzdFZhbHVlcyhyZXNvbHZlZE9wcykpIHtcbiAgICAgIHJlc3VsdCA9IG1pbmdvUXVlcnkudGVzdChyZXNvbHZlZE9wcyk7XG4gICAgfVxuICAgIHJldHVybiB7IGRlY2lzaW9uOiByZXN1bHQgPyBcImFjY2VwdFwiIDogXCJyZWplY3RcIiB9O1xuICB9XG4gIHBnYXRlKGN0eCkge1xuICAgIHRoaXMucHJpbnQoXCJwZ2F0ZVwiLCB0aGlzLm5vZGVUZXh0KTtcbiAgICBjb25zdCBvcmlnaW5hbCA9IHRoaXMubm9kZVRleHQ7XG4gICAgY29uc3QgaWRlbnQgPSBvcmlnaW5hbC5yZXBsYWNlKHRoaXMuU3ltYm9scy5QRU5ESU5HX0dBVEUsIFwiXCIpO1xuICAgIGNvbnN0IGxvb2t1cCA9IHRoaXMucGVuZGluZ0dhdGVzW2lkZW50XTtcbiAgICBpZiAoIWxvb2t1cCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ25vIHBlbmRpbmcgZ2F0ZT1cIicgKyBvcmlnaW5hbCArICdcIiBwZ2F0ZXM9JyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHRoaXMucGVuZGluZ0dhdGVzKSkpO1xuICAgIH1cbiAgICBjb25zdCBzdGlsbFVucmVzb2x2ZWQgPSBsb29rdXAub3BlcmFuZHMuc29tZSgobykgPT4ge1xuICAgICAgbGV0IHsgcmVzdWx0LCByZXNvbHZlZCB9ID0gdGhpcy5jaGVja0NvbnRleHQobyk7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jYWxsKCk7XG4gICAgICAgIHJlc29sdmVkID0gIXRoaXMuc2NyaXB0aW5nLmlzUGFyc2VhYmxlKHJlc3VsdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhcmVzb2x2ZWQ7XG4gICAgfSk7XG4gICAgaWYgKHN0aWxsVW5yZXNvbHZlZClcbiAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICByZXR1cm4gdGhpcy5jaG9pY2UobG9va3VwLmRlZmVycmVkQ29udGV4dCk7XG4gIH1cbiAgZWxzZShjdHgpIHtcbiAgICByZXR1cm4gdGhpcy52aXNpdChjdHguZXhwcikudHJpbSgpO1xuICB9XG4gIC8vIEhlbHBlcnMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGhhc05vUmVwZWF0KHRmcykge1xuICAgIGNvbnN0IHRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1OYW1lcyh0ZnMpO1xuICAgIGlmICh0cmFuc2Zvcm1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybXMuaW5jbHVkZXMoXCJuclwiKSB8fCB0cmFuc2Zvcm1zLmluY2x1ZGVzKFwibm9yZXBlYXRcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaGVja0NvbnRleHQoaWRlbnQsIG9wdHMgPSB7fSkge1xuICAgIGxldCBpc1N0YXRpYyA9IGZhbHNlO1xuICAgIGxldCBpc1VzZXIgPSBmYWxzZTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChpZGVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7IHJlc3VsdDogXCJcIiwgcmVzb2x2ZWQ6IHRydWUsIGlzU3RhdGljLCBpc1VzZXIgfTtcbiAgICB9XG4gICAgcmVzdWx0ID0gdGhpcy5keW5hbWljc1tpZGVudF07XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuc3RhdGljc1tpZGVudF07XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmNvbnRleHRbaWRlbnRdO1xuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaXNVc2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuc2NyaXB0aW5nLnRyYW5zZm9ybXNbaWRlbnRdO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZCA9ICF0aGlzLnNjcmlwdGluZy5pc1BhcnNlYWJsZShyZXN1bHQpO1xuICAgIHJldHVybiB7IHJlc3VsdCwgaXNTdGF0aWMsIGlzVXNlciwgcmVzb2x2ZWQgfTtcbiAgfVxuICBpbmxpbmVTdGF0aWNBc3NpZ24oaWRlbnQsIHRmcywgcmVzdWx0KSB7XG4gICAgY29uc3QgJCA9IHRoaXMuU3ltYm9scztcbiAgICBjb25zdCBsaHMgPSAkLlNUQVRJQyArIGlkZW50O1xuICAgIGNvbnN0IHJocyA9IHJlc3VsdDtcbiAgICBsZXQgc3RtdCA9ICQuT1BFTl9DSE9JQ0UgKyAobGhzICsgXCI9XCIgKyByaHMpICsgJC5DTE9TRV9DSE9JQ0U7XG4gICAgcmVzdWx0ID0gdGhpcy5yZXN0b3JlVHJhbnNmb3JtcyhzdG10LCB0ZnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2hvaWNlSWQoY3R4KSB7XG4gICAgaWYgKCFjdHguT0MgfHwgIWN0eC5PQy5sZW5ndGgpXG4gICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgY2hvaWNlXCIpO1xuICAgIHJldHVybiBjdHguT0NbMF0uc3RhcnRPZmZzZXQgKyBcIi5cIiArIGN0eC5PQ1swXS5lbmRPZmZzZXQ7XG4gIH1cbiAgcGFyc2VPcHRpb25zKGN0eCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBbXTtcbiAgICBpZiAoY3R4ICYmIGN0eD8uY2hpbGRyZW4/LndleHByKSB7XG4gICAgICBjb25zdCB3ZXhwcnMgPSBjdHguY2hpbGRyZW4ud2V4cHI7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdleHBycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB3ZXhwciA9IHdleHByc1tpXTtcbiAgICAgICAgY29uc3QgZXhwciA9IHdleHByLmNoaWxkcmVuLmV4cHI7XG4gICAgICAgIGlmIChleHByICYmIGV4cHIubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgY2hvaWNlLWV4cHI6IFwiICsgZXhwci5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdlaWdodCA9IHdleHByLmNoaWxkcmVuLldlaWdodDtcbiAgICAgICAgaWYgKHdlaWdodCkge1xuICAgICAgICAgIGlmICh3ZWlnaHQubGVuZ3RoICE9IDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3ZWlnaHQ6IFwiICsgd2VpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBtdWx0ID0gMTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbXVsdCA9IHBhcnNlSW50KFxuICAgICAgICAgICAgICB0aGlzLlN5bWJvbHMuQ0xPU0VfV0VJR0hULmxlbmd0aCA/IHdlaWdodFswXS5pbWFnZS50cmltKCkuc2xpY2UoMSwgLTEpIDogd2VpZ2h0WzBdLmltYWdlLnRyaW0oKS5zbGljZSgxKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVYOiBcIiArIG11bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBBcnJheS5mcm9tKHsgbGVuZ3RoOiBtdWx0IH0sICgpID0+IG9wdGlvbnMucHVzaChleHByKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5wdXNoKGV4cHIgfHwgXCJcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgYXBwbHlUcmFuc2Zvcm1zKHZhbHVlLCB0eHMpIHtcbiAgICB0aGlzLmluZGVudCsrO1xuICAgIGlmICh0aGlzLnRyYWNlVHgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiYXBwbHlUcmFuc2Zvcm1zXCIsIHRoaXMuZm9ybWF0VHhzKC4uLmFyZ3VtZW50cykpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR4cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHZhbHVlLCB0eHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLmluZGVudC0tO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBhcHBseVRyYW5zZm9ybSh0YXJnZXQsIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGltYWdlID0gdHJhbnNmb3JtLmltYWdlO1xuICAgIGNvbnN0IHJhdyA9IHRhcmdldCArIGltYWdlO1xuICAgIGNvbnN0IG9yaWdpbmFsID0gZm9ybWF0QW55KHRhcmdldCkgKyBpbWFnZTtcbiAgICBjb25zdCB0eCA9IGltYWdlLnN1YnN0cmluZygxKS5yZXBsYWNlKC9cXChcXCkkLywgXCJcIik7XG4gICAgY29uc3QgUmlUYSA9IHRoaXMuc2NyaXB0aW5nLlJpVGE7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAodHlwZW9mIHRoaXMuZHluYW1pY3NbdHhdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuZHluYW1pY3NbdHhdLmJpbmQodGhpcy5jb250ZXh0KSh0YXJnZXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuc3RhdGljc1t0eF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVzdWx0ID0gdGhpcy5zdGF0aWNzW3R4XS5jYWxsKHRoaXMuY29udGV4dCwgdGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNvbnRleHRbdHhdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuY29udGV4dFt0eF0uY2FsbCh0aGlzLmNvbnRleHQsIHRhcmdldCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5zY3JpcHRpbmcudHJhbnNmb3Jtc1t0eF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmVzdWx0ID0gdGhpcy5zY3JpcHRpbmcudHJhbnNmb3Jtc1t0eF0uY2FsbCh0aGlzLmNvbnRleHQsIHRhcmdldCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGFyZ2V0W3R4XSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXN1bHQgPSB0YXJnZXRbdHhdKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkodHgpKSB7XG4gICAgICAgIHJlc3VsdCA9IHRhcmdldFt0eF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIVJpVGEuU0lMRU5UICYmICF0aGlzLnNpbGVudCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOXSBVbnJlc29sdmVkIHRyYW5zZm9ybTogXCIgKyByYXcpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IHJhdy5yZXBsYWNlKC9cXChcXCkkLywgXCImbHBhcjsmcnBhcjtcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJpbnQoXCJ0cmFuc2Zvcm0vXCIsIGAke29yaWdpbmFsfSAtPiAnJHtyZXN1bHR9J2ApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gdmFsdWUgaXMgbm90IHlldCByZXNvbHZlZCwgc28gc3RvcmUgd2l0aCB0cmFuc2Zvcm0gZm9yIGxhdGVyXG4gIHJlc3RvcmVUcmFuc2Zvcm1zKHZhbHVlLCB0eHMpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjaG9pY2VSRSA9IG5ldyBSZWdFeHAoXCJeXCIgKyB0aGlzLkVzY2FwZWQuT1BFTl9DSE9JQ0UgKyBcIi4qXCIgKyB0aGlzLkVzY2FwZWQuQ0xPU0VfQ0hPSUNFICsgXCIkXCIpO1xuICAgICAgY29uc3Qgc3ltYm9sUkUgPSBuZXcgUmVnRXhwKGAoJHt0aGlzLkVzY2FwZWQuRFlOQU1JQ318JHt0aGlzLkVzY2FwZWQuU1RBVElDfVtBLVphLXpfMC05XSlbQS1aYS16XzAtOV0qYCk7XG4gICAgICBpZiAoIWNob2ljZVJFLnRlc3QodmFsdWUpICYmICFzeW1ib2xSRS50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRoaXMuU3ltYm9scy5PUEVOX0NIT0lDRSArIHZhbHVlICsgdGhpcy5TeW1ib2xzLkNMT1NFX0NIT0lDRTtcbiAgICAgIH1cbiAgICAgIGlmICh0eHMpIHtcbiAgICAgICAgdHhzLmZvckVhY2goKHR4KSA9PiB2YWx1ZSArPSB0eC5pbWFnZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50cmFjZVR4KVxuICAgICAgICBjb25zb2xlLmxvZyhcInJlc3RvcmVUcmFuc2Zvcm1zOlwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjYXN0VmFsdWVzKG9iaikge1xuICAgIGxldCBtYWRlQ2FzdCA9IGZhbHNlO1xuICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICBjb25zdCBudW0gPSBwYXJzZUZsb2F0KHYpO1xuICAgICAgaWYgKCFpc05hTihudW0pKSB7XG4gICAgICAgIG1hZGVDYXN0ID0gdHJ1ZTtcbiAgICAgICAgb2JqW2tdID0gbnVtO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYWRlQ2FzdDtcbiAgfVxuICBjb250ZXh0SXNSZXNvbHZlZCh0YWJsZSkge1xuICAgIGxldCBhbGxSZXNvbHZlZCA9IHRydWU7XG4gICAgT2JqZWN0LmVudHJpZXModGFibGUpLmZvckVhY2goKFtrZXksIHZhbF0pID0+IHtcbiAgICAgIGlmICghdGhpcy5zY3JpcHRpbmcuaXNQYXJzZWFibGUodmFsKSkge1xuICAgICAgICBhbGxSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbGxSZXNvbHZlZDtcbiAgfVxuICBsb29rdXBzVG9TdHJpbmcoKSB7XG4gICAgY29uc3QgZHlucyA9IHt9LCBzdGF0cyA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZHluYW1pY3MgfHwge30pLmZvckVhY2goKFtrLCB2XSkgPT4gZHluc1tgJCR7a31gXSA9IHYpO1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuc3RhdGljcyB8fCB7fSkuZm9yRWFjaCgoW2ssIHZdKSA9PiBzdGF0c1tgIyR7a31gXSA9IHYpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IC4uLnRoaXMuY29udGV4dCwgLi4uc3RhdHMsIC4uLmR5bnMgfSwgKGssIHYpID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgPyBcIjxmKjpwZW5kaW5nPlwiIDogdikucmVwbGFjZSgvXCIvZywgXCJcIik7XG4gIH1cbiAgZm9ybWF0VHhzKHZhbHVlLCB0eHMpIHtcbiAgICByZXR1cm4gdmFsdWUgKyB0eHMubWFwKCh0eCkgPT4gdHguaW1hZ2UucmVwbGFjZSgvKCkvLCBcIlwiKSArIFwiKClcIikuam9pbihcIlwiKTtcbiAgfVxuICBwcmludChzLCAuLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMudHJhY2UpIHtcbiAgICAgIGxldCBpbmRlbnRTdHIgPSBcIiAgXCIucmVwZWF0KHRoaXMuaW5kZW50KTtcbiAgICAgIGxldCBtc2cgPSBgJHtpbmRlbnRTdHJ9PCR7c30+JHtzLnN0YXJ0c1dpdGgoXCIvXCIpID8gXCJcIiA6IFwiIFwifWA7XG4gICAgICBpZiAoKyt0aGlzLm9yZGVyIDwgMTApXG4gICAgICAgIG1zZyA9IFwiIFwiICsgbXNnO1xuICAgICAgY29uc29sZS5sb2codGhpcy5vcmRlciwgbXNnLCAuLi5hcmdzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy90b2tlbnMuanNcbmltcG9ydCB7IGNyZWF0ZVRva2VuIH0gZnJvbSBcImNoZXZyb3RhaW5cIjtcbmZ1bmN0aW9uIGdldFRva2Vucyh2MkNvbXBhdGlibGUpIHtcbiAgbGV0IFN5bWJvbHMgPSB7XG4gICAgT1I6IFwifFwiLFxuICAgIEVMU0U6IFwifHxcIixcbiAgICBEWU5BTUlDOiBcIiRcIixcbiAgICBTVEFUSUM6IFwiI1wiLFxuICAgIEVOVElUWTogXCImXCIsXG4gICAgT1BFTl9HQVRFOiBcIkBcIixcbiAgICBQRU5ESU5HX0dBVEU6IFwiQEBcIixcbiAgICBPUEVOX1NJTEVOVDogXCJ7XCIsXG4gICAgQ0xPU0VfU0lMRU5UOiBcIn1cIlxuICB9O1xuICBsZXQgdjJTeW1ib2xzID0ge1xuICAgIE9QRU5fQ0hPSUNFOiBcIihcIixcbiAgICBDTE9TRV9DSE9JQ0U6IFwiKVwiLFxuICAgIE9QRU5fV0VJR0hUOiBcIltcIixcbiAgICBDTE9TRV9XRUlHSFQ6IFwiXVwiLFxuICAgIENPTlRJTlVBVElPTjogXCJcXFxcXCJcbiAgfTtcbiAgbGV0IHYzU3ltYm9scyA9IHtcbiAgICBPUEVOX0NIT0lDRTogXCJbXCIsXG4gICAgQ0xPU0VfQ0hPSUNFOiBcIl1cIixcbiAgICBPUEVOX1dFSUdIVDogXCJeXCIsXG4gICAgLy8gYWxzbyBhbGxvd3MgKGludCksIGVnLiAoMylcbiAgICBDTE9TRV9XRUlHSFQ6IFwiXlwiLFxuICAgIENPTlRJTlVBVElPTjogXCJ+XCJcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihTeW1ib2xzLCB2MkNvbXBhdGlibGUgPyB2MlN5bWJvbHMgOiB2M1N5bWJvbHMpO1xuICBjb25zdCBFc2NhcGVkID0ge307XG4gIE9iamVjdC5lbnRyaWVzKFN5bWJvbHMpLmZvckVhY2goKFtrLCB2XSkgPT4ge1xuICAgIEVzY2FwZWRba10gPSBlc2NhcGVSZWdleCh2KTtcbiAgfSk7XG4gIGNvbnN0IEVOVElUWV9QQVRURVJOID0gLyYoW2EtejAtOV0rfCNbMC05XXsxLDZ9fCN4WzAtOWEtZkEtRl17MSw2fSk7L2k7XG4gIGNvbnN0IFBFTkRJTkdfR0FURV9QQVRURVJOID0gbmV3IFJlZ0V4cChgJHtFc2NhcGVkLlBFTkRJTkdfR0FURX0oWzAtOV17OSwxMX0pYCk7XG4gIEVzY2FwZWQuU1BFQ0lBTCA9IE9iamVjdC52YWx1ZXMoRXNjYXBlZCkuam9pbihcIlwiKS5yZXBsYWNlKC9bPD5AXS9nLCBcIlwiKTtcbiAgY29uc3QgRFlOID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkRZTlwiLCBwYXR0ZXJuOiBuZXcgUmVnRXhwKEVzY2FwZWQuRFlOQU1JQykgfSk7XG4gIGNvbnN0IFNUQVQgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiU1RBVFwiLCBwYXR0ZXJuOiBuZXcgUmVnRXhwKEVzY2FwZWQuU1RBVElDKSB9KTtcbiAgY29uc3QgT0MgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiT0NcIiwgcGF0dGVybjogbmV3IFJlZ0V4cChFc2NhcGVkLk9QRU5fQ0hPSUNFICsgXCJcXFxccypcIikgfSk7XG4gIGNvbnN0IENDID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkNDXCIsIHBhdHRlcm46IG5ldyBSZWdFeHAoYFxcXFxzKiR7RXNjYXBlZC5DTE9TRV9DSE9JQ0V9YCkgfSk7XG4gIGNvbnN0IE9TID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIk9TXCIsIHBhdHRlcm46IG5ldyBSZWdFeHAoYCR7RXNjYXBlZC5PUEVOX1NJTEVOVH1cXFxccypgKSB9KTtcbiAgY29uc3QgQ1MgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiQ1NcIiwgcGF0dGVybjogbmV3IFJlZ0V4cChgXFxcXHMqJHtFc2NhcGVkLkNMT1NFX1NJTEVOVH1gKSB9KTtcbiAgY29uc3QgRUxTRSA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJFTFNFXCIsIHBhdHRlcm46IC9cXHMqXFx8XFx8XFxzKi8gfSk7XG4gIGNvbnN0IE9SID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIk9SXCIsIHBhdHRlcm46IC9cXHMqXFx8XFxzKi8gfSk7XG4gIGNvbnN0IEVRID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkVRXCIsIHBhdHRlcm46IC9cXHMqPVxccyovIH0pO1xuICBjb25zdCBBTVAgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiQU1QXCIsIHBhdHRlcm46IC8mLyB9KTtcbiAgY29uc3QgU3ltYm9sMiA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJTeW1ib2xcIiwgcGF0dGVybjogbmV3IFJlZ0V4cChgKCR7RXNjYXBlZC5EWU5BTUlDfXwke0VzY2FwZWQuU1RBVElDfVtBLVphLXpfMC05XSlbQS1aYS16XzAtOV0qKFxcXFwoXFxcXCkpP2ApIH0pO1xuICBjb25zdCBUcmFuc2Zvcm0gPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiVHJhbnNmb3JtXCIsIHBhdHRlcm46IC9cXC5bQS1aYS16XzAtOV1bQS1aYS16XzAtOV0qKFxcKFxcKSk/LyB9KTtcbiAgY29uc3QgRW50aXR5ID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkVudGl0eVwiLCBwYXR0ZXJuOiBFTlRJVFlfUEFUVEVSTiB9KTtcbiAgY29uc3QgV2VpZ2h0ID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIldlaWdodFwiLCBwYXR0ZXJuOiBuZXcgUmVnRXhwKGBcXFxccyoke0VzY2FwZWQuT1BFTl9XRUlHSFR9XFxcXGQrJHtFc2NhcGVkLkNMT1NFX1dFSUdIVH1cXFxccypgKSB9KTtcbiAgY29uc3QgUGVuZGluZ0dhdGUgPSBjcmVhdGVUb2tlbih7IG5hbWU6IFwiUGVuZGluZ0dhdGVcIiwgcGF0dGVybjogUEVORElOR19HQVRFX1BBVFRFUk4gfSk7XG4gIGNvbnN0IFJhdyA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJSYXdcIiwgcGF0dGVybjogbmV3IFJlZ0V4cChgW14ke0VzY2FwZWQuU1BFQ0lBTH1dK2ApIH0pO1xuICBjb25zdCBHYXRlID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkdhdGVcIiwgbGluZV9icmVha3M6IHRydWUsIHBhdHRlcm46IGJyYWNrZXRNYXRjaCB9KTtcbiAgY29uc3QgdG9rZW5zID0gW0dhdGUsIEVudGl0eSwgV2VpZ2h0LCBFTFNFLCBPQywgQ0MsIE9SLCBFUSwgU3ltYm9sMiwgRFlOLCBTVEFULCBBTVAsIFRyYW5zZm9ybSwgT1MsIENTLCBQZW5kaW5nR2F0ZSwgUmF3XTtcbiAgcmV0dXJuIHsgdG9rZW5zLCBDb25zdGFudHM6IHsgU3ltYm9scywgRXNjYXBlZCB9IH07XG59XG5mdW5jdGlvbiBicmFja2V0TWF0Y2godGV4dCwgc3RhcnRPZmZzZXQpIHtcbiAgaWYgKCEvXkAvLnRlc3QodGV4dC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQpKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgMTtcbiAgbGV0IGRidWcgPSAwO1xuICBpZiAoZGJ1ZylcbiAgICBjb25zb2xlLmxvZyhcImJyYWNrZXRNYXRjaFwiLCB0ZXh0KTtcbiAgbGV0IGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGVuZE9mZnNldCk7XG4gIHdoaWxlIChjaGFyQ29kZSA9PT0gMzIpIHtcbiAgICBlbmRPZmZzZXQrKztcbiAgICBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChlbmRPZmZzZXQpO1xuICB9XG4gIGlmIChjaGFyQ29kZSAhPT0gMTIzKSB7XG4gICAgaWYgKGRidWcpXG4gICAgICBjb25zb2xlLmxvZyhgICBcIiR7dGV4dC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCl9XCIgLT4gbnVsbDFgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBlbmRPZmZzZXQrKztcbiAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoZW5kT2Zmc2V0KTtcbiAgbGV0IGRlcHRoID0gMTtcbiAgd2hpbGUgKGRlcHRoID4gMCkge1xuICAgIGlmIChjaGFyQ29kZSA9PT0gMTIzKVxuICAgICAgZGVwdGgrKztcbiAgICBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMTI1KVxuICAgICAgZGVwdGgtLTtcbiAgICBpZiAoZGJ1ZylcbiAgICAgIGNvbnNvbGUubG9nKFwiICBkZXB0aFwiLCBkZXB0aCwgdGV4dC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkpO1xuICAgIGVuZE9mZnNldCsrO1xuICAgIGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGVuZE9mZnNldCk7XG4gIH1cbiAgaWYgKGVuZE9mZnNldCA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICBpZiAoZGJ1ZylcbiAgICAgIGNvbnNvbGUubG9nKGBcIiR7dGV4dC5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCl9XCIgLT4gbnVsbDNgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBsZXQgbWF0Y2hlZFN0cmluZyA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgIGlmIChkYnVnKVxuICAgICAgY29uc29sZS5sb2coXCIgIHJldHVybmVkIC0+IFwiLCBbbWF0Y2hlZFN0cmluZ10pO1xuICAgIHJldHVybiBbbWF0Y2hlZFN0cmluZ107XG4gIH1cbn1cbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCBcIlxcXFwkJlwiKTtcbn1cbnZhciBUZXh0VHlwZXMgPSBbXCJSYXdcIiwgXCJTVEFUXCIsIFwiQU1QXCJdO1xuXG4vLyBzcmMvZ3JhbW1hci5qc1xudmFyIF9SaUdyYW1tYXIgPSBjbGFzcyBfUmlHcmFtbWFyIHtcbiAgLy8gYXNzaWduZWQgaW4gcmlzY3JpcHQuanNcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmlHcmFtbWFyLlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz58c3RyaW5nfSBbcnVsZXNdIC0gYW4gb2JqZWN0IChvciBKU09OIHN0cmluZykgY29udGFpbmluZyB0aGUgcnVsZXNcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbY29udGV4dF0gLSB0aGUgY29udGV4dCAob3Igd29ybGQtc3RhdGUpXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgdGhlIGdyYW1tYXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJ1bGVzID0ge30sIGNvbnRleHQgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5ydWxlcyA9IHt9O1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5zY3JpcHRpbmcgPSBvcHRpb25zLlJpVGE/LnJpc2NyaXB0ID8/IG5ldyBSaVNjcmlwdChvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIHJ1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBydWxlcyA9IHBhcnNlSlNPTihydWxlcyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcnVsZXMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IEVycm9yKFwiUmlHcmFtbWFyOiBleHBlY3Rpbmcgb2JqZWN0LCBmb3VuZCBcIiArIHR5cGVvZiBydWxlcyk7XG4gICAgfVxuICAgIHRoaXMuc2V0UnVsZXMocnVsZXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJpR3JhbW1hciBmcm9tIHRoZSBgcnVsZXNgLCBgY29udGV4dGAgYW5kIGBvcHRpb25zYCwgdGhlbiBjYWxscyBgZXhwYW5kKClgIG9uIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZXMgLSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcnVsZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIHRoZSBjb250ZXh0IChvciB3b3JsZC1zdGF0ZSkgZm9yIHRoZSBleHBhbnNpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIHRoZSBleHBhbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN0YXJ0PSckc3RhcnQnXSAtIHRoZSBydWxlIHRvIHN0YXJ0IGZyb21cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFjZT1mYWxzZV0gLSB3aGV0aGVyIHRvIHRyYWNlIHRoZSBldmFsdWF0aW9uIHRvIHRoZSBjb25zb2xlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMub25lcGFzcz1mYWxzZV0gLSB3aGV0aGVyIHRvIG9ubHkgZG8gb25lIGV2YWx1YXRpb24gcGFzcyBcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zaWxlbnQ9ZmFsc2VdIC0gd2hldGhlciB0byBzdXBwcmVzcyBjb25zb2xlIHdhcm5pbmdzXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gdGhlIGV4cGFuZGVkIHRleHRcbiAgICovXG4gIHN0YXRpYyBleHBhbmQocnVsZXMsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IF9SaUdyYW1tYXIocnVsZXMsIGNvbnRleHQpLmV4cGFuZChvcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHRyYW5zZm9ybSB0byB0aGUgR3JhbW1hciBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmIC0gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIGEgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtSaUdyYW1tYXJ9IC0gdGhlIFJpR3JhbW1hciBpbnN0YW5jZVxuICAgKi9cbiAgYWRkVHJhbnNmb3JtKG5hbWUsIGRlZikge1xuICAgIHRoaXMuc2NyaXB0aW5nLmFkZFRyYW5zZm9ybShuYW1lLCBkZWYpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdHJhbnNmb3JtIGZyb20gdGhlIEdyYW1tYXIgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgXG4gICAqIEByZXR1cm5zIHtSaUdyYW1tYXJ9IC0gdGhlIFJpR3JhbW1hciBpbnN0YW5jZVxuICAgKi9cbiAgcmVtb3ZlVHJhbnNmb3JtKG5hbWUpIHtcbiAgICB0aGlzLnNjcmlwdGluZy5yZW1vdmVUcmFuc2Zvcm0obmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGFsbCBjdXJyZW50IHRyYW5zZm9ybXNcbiAgICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgbmFtZXMgb2YgdGhlIHRyYW5zZm9ybXNcbiAgICovXG4gIGdldFRyYW5zZm9ybXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyaXB0aW5nLmdldFRyYW5zZm9ybXMoKTtcbiAgfVxuICAvKipcbiAgICogVGVzdHMgd2hldGhlciB0d28gZ3JhbW1hcnMgYXJlIGVxdWFsIGFuZCByZXR1cm5zIGEgYm9vbGVhblxuICAgKiBAcGFyYW0ge1JpR3JhbW1hcn0gcmcgLSB0aGUgZ3JhbW1hciB0byBjb21wYXJlIHRvIFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB3aGV0aGVyIHRoZSBncmFtbWFycyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhyZykge1xuICAgIHJldHVybiByZy50b0pTT04oKSA9PT0gdGhpcy50b0pTT04oKTtcbiAgfVxuICAvKipcbiAgICogRXhwYW5kcyBhIGdyYW1tYXIgZnJvbSB0aGUgc3VwcGxpZWQgcnVsZS4gSWYgbm8gcnVsZSBpcyBwcm92aWRlZCB0aGUgYCRzdGFydGAgYW5kIGA8c3RhcnQ+YFxuICAgKiAgc3ltYm9scyB3aWxsIGJlIGNoZWNrZWQgcmVzcGVjdGl2ZWx5LiBJZiBhIGNvbnRleHQgaXMgbmVlZGVkLCBpdCBzaG91bGQgYmUgcGFzc2VkIHdoZW4gdGhlXG4gICAqICBncmFtbWFyIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciB0aGUgZXhwYW5zaW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdGFydD0nJHN0YXJ0J10gLSB0aGUgcnVsZSB0byBzdGFydCBmcm9tXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhY2U9ZmFsc2VdIC0gd2hldGhlciB0byB0cmFjZSB0aGUgZXZhbHVhdGlvbiB0byB0aGUgY29uc29sZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm9uZXBhc3M9ZmFsc2VdIC0gd2hldGhlciB0byBvbmx5IGRvIG9uZSBldmFsdWF0aW9uIHBhc3MgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2lsZW50PWZhbHNlXSAtIHdoZXRoZXIgdG8gc3VwcHJlc3MgY29uc29sZSB3YXJuaW5nc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBleHBhbmRlZCB0ZXh0XG4gICAqL1xuICBleHBhbmQob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKFwiY29udGV4dFwiIGluIG9wdGlvbnMpIHtcbiAgICAgIHRocm93IEVycm9yKFwicGFzcyBjb250ZXh0IHRvIFJpU2NyaXB0LmdyYW1tYXIoKSBvciBuZXcgUmlHcmFtbWFyKCkgaW5zdGVhZFwiKTtcbiAgICB9XG4gICAgbGV0IHZpc2l0b3IgPSBuZXcgUmlTY3JpcHRWaXNpdG9yKHRoaXMuc2NyaXB0aW5nKTtcbiAgICB2aXNpdG9yLmNvbnRleHQgPSB0aGlzLmNvbnRleHQgfHwge307XG4gICAgbGV0IGNsb25lZE9wdHMgPSB7IC4uLm9wdGlvbnMsIHZpc2l0b3IsIGlucHV0OiB0aGlzLl90b1NjcmlwdChvcHRpb25zKSB9O1xuICAgIHJldHVybiB0aGlzLnNjcmlwdGluZy5fZXZhbHVhdGUoY2xvbmVkT3B0cyk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhIHJ1bGUgYW5kIGFkZHMgYSBuZXcgcnVsZSB0byB0aGUgZ3JhbW1hclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBydWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZWYgLSB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgcnVsZVxuICAgKiBAcmV0dXJucyB7UmlHcmFtbWFyfSAtIHRoZSBSaUdyYW1tYXIgaW5zdGFuY2VcbiAgICovXG4gIGFkZFJ1bGUobmFtZSwgZGVmKSB7XG4gICAgdGhpcy5fdmFsaWRhdGVSdWxlKG5hbWUsIGRlZik7XG4gICAgdGhpcy5ydWxlc1tuYW1lXSA9IGRlZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgcnVsZXMgZm9yIHRoZSBncmFtbWFyLCByZW1vdmluZyBhbnkgcHJldmlvdXMgcnVsZXNcbiAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBydWxlcyAtIGFuIG9iamVjdCBvciBKU09OIHN0cmluZyBob2xkaW5nIHRoZSBydWxlcyBmb3IgdGhlIGdyYW1tYXIgXG4gICAqIEByZXR1cm5zIHtSaUdyYW1tYXJ9IC0gdGhlIFJpR3JhbW1hciBpbnN0YW5jZVxuICAgKi9cbiAgc2V0UnVsZXMocnVsZXMpIHtcbiAgICBpZiAodHlwZW9mIHJ1bGVzID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgdGhyb3cgRXJyb3IoXCJ1bmRlZmluZWQgcnVsZXNcIik7XG4gICAgdGhpcy5ydWxlcyA9IHt9O1xuICAgIGxldCBpbmNvbWluZyA9IHR5cGVvZiBydWxlcyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlSlNPTihydWxlcykgOiBydWxlcztcbiAgICBPYmplY3QuZW50cmllcyhpbmNvbWluZykuZm9yRWFjaCgoZSkgPT4gdGhpcy5hZGRSdWxlKC4uLmUpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHJ1bGUgZnJvbSB0aGUgZ3JhbW1hclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBydWxlIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7UmlHcmFtbWFyfSAtIHRoZSBSaUdyYW1tYXIgaW5zdGFuY2VcbiAgICovXG4gIHJlbW92ZVJ1bGUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMucnVsZXMpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnJ1bGVzW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyYW1tYXIgcnVsZXMsIGFjY2VwdGluZyBvcHRpb25zIGZyb20gYEpTT04uc3RyaW5naWZ5KClgXG4gICAqIEBwYXJhbSB7YW55fSBbcmVwbGFjZXJdIC0gYSByZXBsYWNlciBmdW5jdGlvbiBvciBhcnJheVxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW3NwYWNlXSAtIHRoZSBudW1iZXIgb2Ygc3BhY2VzIHRvIGluZGVudFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFtbWFyXG4gICAqL1xuICB0b0pTT04ocmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMucnVsZXMsIHJlcGxhY2VyLCBzcGFjZSk7XG4gIH1cbiAgLyoqIFxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBncmFtbWFyLCBhY2NlY3B0aW5nIHRoZSBzYW1lIG9wdGlvbnMgYXMgYEpTT04uc3RyaW5naWZ5KClgXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAqIEBwYXJhbSB7YW55fSBbb3B0aW9ucy5yZXBsYWNlcl0gLSBhIHJlcGxhY2VyIGZ1bmN0aW9uIG9yIGFycmF5XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBbb3B0aW9ucy5zcGFjZV0gLSB0aGUgbnVtYmVyIG9mIHNwYWNlcyB0byBpbmRlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxpbmVicmVha10gLSB0aGUgbGluZWJyZWFrIGNoYXJhY3RlciB0byB1c2VcbiAgICovXG4gIHRvU3RyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCByZXBsYWNlciA9IG9wdGlvbnMucmVwbGFjZXIgfHwgMDtcbiAgICBsZXQgc3BhY2UgPSBvcHRpb25zLnNwYWNlIHx8IDI7XG4gICAgbGV0IGxiID0gb3B0aW9ucz8ubGluZWJyZWFrO1xuICAgIGxldCByZXMgPSB0aGlzLnRvSlNPTihyZXBsYWNlciwgc3BhY2UpO1xuICAgIGlmIChsYilcbiAgICAgIHJlcyA9IHJlcy5yZXBsYWNlKC9cXG4vZywgbGIpO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmlHcmFtbWFyIGZyb20gdGhlIHN1cHBsaWVkIEpTT04gc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBqc29uIC0gYSBKU09OIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGdyYW1tYXJcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIG9wdGlvbmFsIGNvbnRleHQgZm9yIHRoZSBncmFtbWFyXG4gICAqIEByZXR1cm5zIHtSaUdyYW1tYXJ9IC0gdGhlIFJpR3JhbW1hciBpbnN0YW5jZVxuICAgKi9cbiAgc3RhdGljIGZyb21KU09OKGpzb24sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IF9SaUdyYW1tYXIoSlNPTi5wYXJzZShqc29uKSwgY29udGV4dCk7XG4gIH1cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBncmFtbWFyIHRvIGlubGluZSBydWxlczsgcnVsZXMgYXJlIGR5bmFtaWMsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkIHdpdGggbGVhZGluZyAjXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdG9TY3JpcHQob3B0cykge1xuICAgIGxldCBzY3JpcHQgPSBcIlwiLCBzdGFydCA9IG9wdHMuc3RhcnQgfHwgXCJzdGFydFwiO1xuICAgIGxldCB7IFN5bWJvbHMgfSA9IHRoaXMuc2NyaXB0aW5nO1xuICAgIGlmIChzdGFydC5zdGFydHNXaXRoKFN5bWJvbHMuRFlOQU1JQykpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQuc3Vic3RyaW5nKFN5bWJvbHMuRFlOQU1JQy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAoc3RhcnQuc3RhcnRzV2l0aChTeW1ib2xzLlNUQVRJQykpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQuc3Vic3RyaW5nKFN5bWJvbHMuU1RBVElDLmxlbmd0aCk7XG4gICAgfVxuICAgIGlmICghKHN0YXJ0IGluIHRoaXMucnVsZXMgfHwgU3ltYm9scy5TVEFUSUMgKyBzdGFydCBpbiB0aGlzLnJ1bGVzKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1J1bGU6IFwiJyArIHN0YXJ0ICsgJ1wiIG5vdCBmb3VuZCBpbiBncmFtbWFyJyk7XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMucnVsZXMpLmZvckVhY2goKFtuYW1lLCBydWxlXSwgaSkgPT4ge1xuICAgICAgd2hpbGUgKG5hbWUuc3RhcnRzV2l0aChTeW1ib2xzLkRZTkFNSUMpKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKFN5bWJvbHMuU1RBVElDKSkge1xuICAgICAgICBuYW1lID0gU3ltYm9scy5EWU5BTUlDICsgbmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5zY3JpcHRpbmcucmVnZXguQ2hvaWNlV3JhcC50ZXN0KHJ1bGUpKSB7XG4gICAgICAgIHJ1bGUgPSBTeW1ib2xzLk9QRU5fQ0hPSUNFICsgcnVsZSArIFN5bWJvbHMuQ0xPU0VfQ0hPSUNFO1xuICAgICAgfVxuICAgICAgc2NyaXB0ICs9IGAke25hbWV9PSR7cnVsZX1cbmA7XG4gICAgfSk7XG4gICAgaWYgKG9wdHMudHJhY2UpXG4gICAgICBjb25zb2xlLmxvZyhcIkdyYW1tYXI6XFxuXCIgKyBzY3JpcHQucmVwbGFjZSgvXlxcJC9nbSwgXCIgICRcIikpO1xuICAgIHNjcmlwdCArPSBgJHtTeW1ib2xzLkRZTkFNSUN9JHtzdGFydH1gO1xuICAgIHJldHVybiBzY3JpcHQ7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBhIGdyYW1tYXIgcnVsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlUnVsZShuYW1lLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiZXhwZWN0ZWQgW3N0cmluZ10gbmFtZVwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZWYgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IEVycm9yKFwidW5kZWZpbmVkIHJ1bGUgZGVmOiBcIiArIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgeyBTeW1ib2xzIH0gPSB0aGlzLnNjcmlwdGluZztcbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKFN5bWJvbHMuRFlOQU1JQykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhTeW1ib2xzLkRZTkFNSUMubGVuZ3RoKTtcbiAgICAgIHRocm93IEVycm9yKFwiR3JhbW1hciBydWxlcyBhcmUgZHluYW1pYyBieSBkZWZhdWx0OyBpZiB5b3UgbmVlZCBhIHN0YXRpYyBydWxlLCB1c2UgJ1wiICsgU3ltYm9scy5TVEFUSUMgKyBuYW1lICsgXCInLCBvdGhlcndpc2UganVzdCB1c2UgJ1wiICsgbmFtZSArIFwiJy5cIik7XG4gICAgfVxuICB9XG59O1xuX19wdWJsaWNGaWVsZChfUmlHcmFtbWFyLCBcIlJpU2NyaXB0XCIsIG51bGwpO1xudmFyIFJpR3JhbW1hciA9IF9SaUdyYW1tYXI7XG5mdW5jdGlvbiBwYXJzZUpTT04oanNvbikge1xuICBpZiAodHlwZW9mIGpzb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJSaUdyYW1tYXIgYXBwZWFycyB0byBiZSBpbnZhbGlkIEpTT04sIHBsZWFzZSBjaGVjayBpdCBhdCBodHRwOi8vanNvbmxpbnQuY29tL1xcblwiICsganNvbik7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9yaXNjcmlwdC5qc1xudmFyIHsgZGVjb2RlIH0gPSBoZTtcbnZhciBWb3dlbHMgPSAvW2FlaW91XS87XG52YXIgSHRtbEVudGl0aWVzID0gLyYoW2EtejAtOV0rfCNbMC05XXsxLDZ9fCN4WzAtOWEtZkEtRl17MSw2fSk7L2dpO1xudmFyIHsgZXNjYXBlVGV4dDogZXNjYXBlVGV4dDIsIHNsYXNoRXNjVG9FbnRpdGllcywgZXNjYXBlTWFya2Rvd25MaW5rLCBlc2NhcGVKU09OUmVnZXggfSA9IFV0aWw7XG52YXIgUmlRdWVyeSA9IGNsYXNzIGV4dGVuZHMgUXVlcnkge1xuICBjb25zdHJ1Y3RvcihzY3JpcHRpbmcsIGNvbmRpdGlvbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgY29uZGl0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25kaXRpb24gPSBKU09OLnN0cmluZ2lmeShjb25kaXRpb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihjb25kaXRpb24udG9TdHJpbmcoKS5pbmNsdWRlcyhcIkBcIikgPyBcIlJlcGxhY2UgQCB3aXRoICQgd2hlbiBwYXNzaW5nIGFuIG9iamVjdCB0byBSaVF1ZXJ5XFxuUm9vdDogXCIgKyBlIDogZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uLmluY2x1ZGVzKFwiJFwiKSlcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBHYXRlOiAnXCIgKyBjb25kaXRpb24gKyBcIicgLT4gb3BlcmFuZCBtdXN0IGluY2x1ZGUgJHN5bWJvbCBvciAkZnVuY3Rpb24oKVwiKTtcbiAgICBjb25kaXRpb24gPSBjb25kaXRpb24ucmVwbGFjZSgvKFxcJHxcXChcXCkpL2csIFwiXCIpLnJlcGxhY2UoL0AvZywgXCIkXCIpO1xuICAgIGNvbmRpdGlvbiA9IHNjcmlwdGluZy5wYXJzZUpTT0woY29uZGl0aW9uKTtcbiAgICBzdXBlcihjb25kaXRpb24sIG9wdGlvbnMpO1xuICB9XG4gIHRlc3Qob2JqKSB7XG4gICAgbGV0IGNvbXBpbGVkID0gdGhpcy5jb21waWxlZDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY29tcGlsZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghY29tcGlsZWRbaV0ob2JqKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBvcGVyYW5kcygpIHtcbiAgICBjb25zdCBzdGFjayA9IFt0aGlzLmNvbmRpdGlvbl07XG4gICAgY29uc3Qga2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgd2hpbGUgKHN0YWNrPy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50T2JqID0gc3RhY2sucG9wKCk7XG4gICAgICBPYmplY3Qua2V5cyhjdXJyZW50T2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50T2JqW2tleV07XG4gICAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoXCIkXCIpKVxuICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBlbGVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgICAgICAgZWxlcy5mb3JFYWNoKChlbGUpID0+IHN0YWNrLnB1c2goZWxlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShrZXlzKTtcbiAgfVxufTtcbnZhciBfUmlTY3JpcHQgPSBjbGFzcyBfUmlTY3JpcHQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgUmlUYSBncmFtbWFyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbcnVsZXNdIC0gdGhlIHJ1bGVzIG9mIHRoZSBncmFtbWFyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSB0aGUgY29udGV4dCBvZiB0aGUgZ3JhbW1hclxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgdGhlIGV2YWx1YXRpb25cbiAgICogQHJldHVybnMge1JpR3JhbW1hcn0gLSBhIG5ldyBSaUdyYW1tYXIgaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBncmFtbWFyKHJ1bGVzLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSaUdyYW1tYXIocnVsZXMsIGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgdGhlIGlucHV0IHNjcmlwdCB2aWEgdGhlIFJpU2NyaXB0IHBhcnNlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IC0gdGhlIHNjcmlwdCB0byBldmFsdWF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gdGhlIGNvbnRleHQgKG9yIHdvcmxkLXN0YXRlKSB0byBldmFsdWF0ZSBpblxuICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBmb3IgdGhlIGV2YWx1YXRpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zLlJpVGFdIC0gb3B0aW9uYWxzIFJpVGEgb2JqZWN0IHRvIHVzZSBpbiB0cmFuc2Zvcm1zXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb21wYXRpYmlsaXR5XSAtIHRoZSBSaVRhIGNvbXBhdGliaWxpdHkgbGV2ZWwgKHBhc3MgMiBmb3IgdjIpXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhY2U9ZmFsc2VdIC0gd2hldGhlciB0byB0cmFjZSB0aGUgZXZhbHVhdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIHRoZSBldmFsdWF0ZWQgc2NyaXB0XG4gICAqL1xuICBzdGF0aWMgZXZhbHVhdGUoc2NyaXB0LCBjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gbmV3IF9SaVNjcmlwdChvcHRpb25zKS5ldmFsdWF0ZShzY3JpcHQsIGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJpU2NyaXB0IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGZvciB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucy5SaVRhXSAtIG9wdGlvbmFscyBSaVRhIG9iamVjdCB0byB1c2UgaW4gdHJhbnNmb3Jtc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29tcGF0aWJpbGl0eV0gLSB0aGUgUmlUYSBjb21wYXRpYmlsaXR5IGxldmVsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLkVzY2FwZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5TeW1ib2xzID0gdm9pZCAwO1xuICAgIHRoaXMudmlzaXRvciA9IHZvaWQgMDtcbiAgICB0aGlzLnYyQ29tcGF0aWJsZSA9IG9wdGlvbnMuY29tcGF0aWJpbGl0eSA9PT0gMjtcbiAgICBjb25zdCB7IENvbnN0YW50cywgdG9rZW5zIH0gPSBnZXRUb2tlbnModGhpcy52MkNvbXBhdGlibGUpO1xuICAgICh7IEVzY2FwZWQ6IHRoaXMuRXNjYXBlZCwgU3ltYm9sczogdGhpcy5TeW1ib2xzIH0gPSBDb25zdGFudHMpO1xuICAgIHRoaXMucGVuZGluZ0dhdGVSZSA9IG5ldyBSZWdFeHAoYCR7dGhpcy5Fc2NhcGVkLlBFTkRJTkdfR0FURX0oWzAtOV17OSwxMX0pYCwgXCJnXCIpO1xuICAgIHRoaXMudGV4dFR5cGVzID0gVGV4dFR5cGVzO1xuICAgIHRoaXMuUmlUYSA9IG9wdGlvbnMuUmlUYSB8fCB7XG4gICAgICBWRVJTSU9OOiAwLFxuICAgICAgcmFuZGk6IChrKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBrKVxuICAgIH07XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gdGhpcy5fY3JlYXRlVHJhbnNmb3JtcygpO1xuICAgIHRoaXMucmVnZXggPSB0aGlzLl9jcmVhdGVSZWdleGVzKHRva2Vucyk7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcih0b2tlbnMpO1xuICAgIHRoaXMucGFyc2VyID0gbmV3IFJpU2NyaXB0UGFyc2VyKHRva2VucywgVGV4dFR5cGVzKTtcbiAgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgbGV4KG9wdHMpIHtcbiAgICBpZiAoIW9wdHMuaW5wdXQpXG4gICAgICB0aHJvdyBFcnJvcihcIm5vIGlucHV0XCIpO1xuICAgIGNvbnN0IGxleFJlc3VsdCA9IHRoaXMubGV4ZXIudG9rZW5pemUob3B0cy5pbnB1dCk7XG4gICAgaWYgKGxleFJlc3VsdC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiSW5wdXQ6IFwiICsgb3B0cy5pbnB1dCArIFwiXFxuXCIsIGxleFJlc3VsdC5lcnJvcnNbMF0ubWVzc2FnZSk7XG4gICAgICB0aHJvdyBFcnJvcihcIltMRVhJTkddIFwiICsgbGV4UmVzdWx0LmVycm9yc1swXS5tZXNzYWdlKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudHJhY2VMZXgpXG4gICAgICB0aGlzLl9wcmludFRva2VucyhsZXhSZXN1bHQudG9rZW5zKTtcbiAgICBvcHRzLnRva2VucyA9IGxleFJlc3VsdC50b2tlbnM7XG4gIH1cbiAgLyoqIEBwcml2YXRlICovXG4gIHBhcnNlKG9wdHMpIHtcbiAgICBvcHRzLmNzdCA9IHRoaXMucGFyc2VyLnBhcnNlKG9wdHMpO1xuICB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB2aXNpdChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMudmlzaXRvci5zdGFydChvcHRzKTtcbiAgfVxuICAvKipcbiAgICogRXZhbHVhdGVzIHRoZSBpbnB1dCBzY3JpcHQgdmlhIHRoZSBSaVNjcmlwdCBwYXJzZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdCAtIHRoZSBzY3JpcHQgdG8gZXZhbHVhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XSAtIHRoZSBjb250ZXh0IChvciB3b3JsZC1zdGF0ZSkgdG8gZXZhbHVhdGUgaW5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIHRoZSBldmFsdWF0aW9uXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBldmFsdWF0ZShzY3JpcHQsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHNjcmlwdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgRXJyb3IoXCJldmFsdWF0ZSgpIGV4cGVjdHMgYSBzdHJpbmcsIGdvdCBcIiArIHR5cGVvZiBzY3JpcHQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgb3B0aW9ucy5pbnB1dCA9IHNjcmlwdDtcbiAgICBvcHRpb25zLnZpc2l0b3IgPSBuZXcgUmlTY3JpcHRWaXNpdG9yKHRoaXMsIGNvbnRleHQpO1xuICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZShvcHRpb25zKTtcbiAgfVxuICAvKiogQHByaXZhdGUgKi9cbiAgbGV4UGFyc2VWaXNpdChvcHRzID0ge30pIHtcbiAgICB0aGlzLmxleChvcHRzKTtcbiAgICB0aGlzLnBhcnNlKG9wdHMpO1xuICAgIHJldHVybiB0aGlzLnZpc2l0KG9wdHMpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gdG8gdGhpcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGVmIC0gdGhlIHRyYW5zZm9ybSBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7UmlTY3JpcHR9IHRoaXMgaW5zdGFuY2VcbiAgICovXG4gIGFkZFRyYW5zZm9ybShuYW1lLCBkZWYpIHtcbiAgICB0aGlzLnRyYW5zZm9ybXNbbmFtZV0gPSBkZWY7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWVzIG9mIGFsbCBjdXJyZW50IHRyYW5zZm9ybXNcbiAgICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgbmFtZXMgb2YgdGhlIHRyYW5zZm9ybXNcbiAgICovXG4gIGdldFRyYW5zZm9ybXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudHJhbnNmb3Jtcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gZnJvbSB0aGlzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG9mIHRyYW5zZm9ybSB0byByZW1vdmVcbiAgICogQHJldHVybnMge1JpU2NyaXB0fSB0aGlzIGluc3RhbmNlXG4gICAqL1xuICByZW1vdmVUcmFuc2Zvcm0obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLnRyYW5zZm9ybXNbbmFtZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyBFbmQgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8qKlxuICAgKiBQcml2YXRlIHZlcnNpb24gb2YgZXZhbHVhdGUgdGFraW5nIGFsbCBhcmd1bWVudHMgaW4gdGhlIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIGV2YWx1YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuaW5wdXQgLSB0aGUgc2NyaXB0IHRvIGV2YWx1YXRlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnZpc2l0b3IgLSB0aGUgdmlzaXRvciB0byB1c2UgZm9yIHRoZSBldmFsdWF0aW9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhY2VdIC0gd2hldGhlciB0byB0cmFjZSB0aGUgZXZhbHVhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm9uZXBhc3NdIC0gd2hldGhlciB0byBvbmx5IGRvIG9uZSBwYXNzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2lsZW50XSAtIHdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3NcbiAgICogQHJldHVybnMge3N0cmluZ30gLSB0aGUgZXZhbHVhdGVkIHNjcmlwdCdzIG91dHB1dCB0ZXh0XG4gICAqIEBwYWNrYWdlXG4gICAqL1xuICBfZXZhbHVhdGUob3B0aW9ucykge1xuICAgIGNvbnN0IHsgaW5wdXQsIHZpc2l0b3IsIHRyYWNlLCBvbmVwYXNzLCBzaWxlbnQgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFpbnB1dClcbiAgICAgIHRocm93IEVycm9yKFwibm8gaW5wdXRcIik7XG4gICAgaWYgKCF2aXNpdG9yKVxuICAgICAgdGhyb3cgRXJyb3IoXCJubyB2aXNpdG9yXCIpO1xuICAgIGxldCBsYXN0LCBlbmRpbmdCcmVhayA9IHRoaXMucmVnZXguRW5kaW5nQnJlYWsudGVzdChpbnB1dCk7XG4gICAgbGV0IGV4cHIgPSB0aGlzLl9wcmVQYXJzZShpbnB1dCwgb3B0aW9ucyk7XG4gICAgaWYgKCFleHByKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgaWYgKCFvcHRpb25zLnZpc2l0b3IpXG4gICAgICB0aHJvdyBFcnJvcihcIm5vIHZpc2l0b3JcIik7XG4gICAgdGhpcy52aXNpdG9yID0gb3B0aW9ucy52aXNpdG9yO1xuICAgIGRlbGV0ZSBvcHRpb25zLnZpc2l0b3I7XG4gICAgaWYgKHRyYWNlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgXG5JbnB1dDogICcke2VzY2FwZVRleHQyKGlucHV0KX0nIGN0eD0ke3Zpc2l0b3IubG9va3Vwc1RvU3RyaW5nKCl9YCk7XG4gICAgICBpZiAoaW5wdXQgIT09IGV4cHIpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBhcnNlZDogJyR7ZXNjYXBlVGV4dDIoZXhwcil9J2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgZXhwciAhPT0gbGFzdCAmJiBpIDw9IDEwOyBpKyspIHtcbiAgICAgIGxhc3QgPSBleHByO1xuICAgICAgaWYgKHRyYWNlKVxuICAgICAgICBjb25zb2xlLmxvZyhcIi1cIi5yZXBlYXQoMjApICsgXCIgUGFzcyNcIiArIGkgKyBcIiBcIiArIFwiLVwiLnJlcGVhdCgyMCkpO1xuICAgICAgb3B0aW9ucy5pbnB1dCA9IGV4cHI7XG4gICAgICBleHByID0gdGhpcy5sZXhQYXJzZVZpc2l0KG9wdGlvbnMpID8/IFwiXCI7XG4gICAgICBpZiAodHJhY2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFJlc3VsdCgke2l9KSAtPiBcIiR7ZXNjYXBlVGV4dDIoZXhwciB8fCBcIlwiKX1cIiBjdHg9JHt0aGlzLnZpc2l0b3IubG9va3Vwc1RvU3RyaW5nKCl9YCk7XG4gICAgICB9XG4gICAgICBpZiAob25lcGFzcyB8fCAhdGhpcy5pc1BhcnNlYWJsZShleHByKSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghc2lsZW50ICYmICF0aGlzLlJpVGEuU0lMRU5UKSB7XG4gICAgICBpZiAodGhpcy5yZWdleC5WYWxpZFN5bWJvbC50ZXN0KGV4cHIucmVwbGFjZShIdG1sRW50aXRpZXMsIFwiXCIpKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tXQVJOXSBVbnJlc29sdmVkIHN5bWJvbChzKSBpbiBcIicgKyBleHByLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpICsgJ1wiICcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcG9zdFBhcnNlKGV4cHIsIG9wdGlvbnMpICsgKGVuZGluZ0JyZWFrID8gXCJcXG5cIiA6IFwiXCIpO1xuICB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfcHJpbnRUb2tlbnModG9rZW5zKSB7XG4gICAgbGV0IHMgPSB0b2tlbnMucmVkdWNlKChzdHIsIHQpID0+IHtcbiAgICAgIGxldCB7IG5hbWUgfSA9IHQudG9rZW5UeXBlO1xuICAgICAgbGV0IHRhZyA9IG5hbWU7XG4gICAgICBpZiAodGFnID09PSBcIlRFWFRcIilcbiAgICAgICAgdGFnID0gZXNjYXBlVGV4dDIodC5pbWFnZSwgdHJ1ZSk7XG4gICAgICBpZiAodGFnID09PSBcIlN5bWJvbFwiKVxuICAgICAgICB0YWcgPSBcInN5bShcIiArIHQuaW1hZ2UgKyBcIilcIjtcbiAgICAgIGlmICh0YWcgPT09IFwiVFhcIilcbiAgICAgICAgdGFnID0gXCJ0eChcIiArIHQuaW1hZ2UgKyBcIilcIjtcbiAgICAgIHJldHVybiBzdHIgKyB0YWcgKyBcIiwgXCI7XG4gICAgfSwgXCJcIikuc2xpY2UoMCwgLTIpO1xuICAgIGNvbnNvbGUubG9nKFwiXFxuVG9rZW5zOiBbIFwiICsgcyArIFwiIF1cXG5cIik7XG4gIH1cbiAgLyoqIEBwcml2YXRlICovXG4gIF9wcmVQYXJzZShzY3JpcHQsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIHNjcmlwdCAhPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGNvbnN0ICQgPSB0aGlzLlN5bWJvbHM7XG4gICAgbGV0IGlucHV0ID0gc2NyaXB0O1xuICAgIGlmICghdGhpcy52MkNvbXBhdGlibGUpIHtcbiAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSh0aGlzLnJlZ2V4LlBhcmVudGhlc2l6ZWRXZWlnaHRzLCBcIl4kMV5cIik7XG4gICAgfVxuICAgIGxldCBtYXRjaGVzID0gaW5wdXQubWF0Y2godGhpcy5yZWdleC5NYXJrZG93bkxpbmtzKTtcbiAgICBtYXRjaGVzICYmIG1hdGNoZXMuZm9yRWFjaCgobSkgPT4gaW5wdXQgPSBpbnB1dC5yZXBsYWNlKG0sIGVzY2FwZU1hcmtkb3duTGluayhtKSkpO1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSh0aGlzLnJlZ2V4Lk11bHRpTGluZUNvbW1lbnRzLCBcIlwiKTtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UodGhpcy5yZWdleC5TaW5nbGVMaW5lQ29tbWVudHMsIFwiXCIpO1xuICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZSh0aGlzLnJlZ2V4LkNvbnRpbnVlLCBcIlwiKTtcbiAgICBpbnB1dCA9IHNsYXNoRXNjVG9FbnRpdGllcyhpbnB1dCk7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgbGV0IGxpbmVzID0gaW5wdXQuc3BsaXQodGhpcy5yZWdleC5MaW5lQnJlYWtzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5yZWdleC5SYXdBc3NpZ24udGVzdChsaW5lc1tpXSkpIHtcbiAgICAgICAgbGV0IGVxSWR4ID0gbGluZXNbaV0uaW5kZXhPZihcIj1cIik7XG4gICAgICAgIGlmIChlcUlkeCA8IDApXG4gICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHN0YXRlOiBubyBhc3NpZ21lbnQ6IFwiICsgbGluZXNbaV0pO1xuICAgICAgICBsZXQgbGhzID0gbGluZXNbaV0uc3Vic3RyaW5nKDAsIGVxSWR4KSwgcmhzID0gbGluZXNbaV0uc3Vic3RyaW5nKGVxSWR4ICsgMSk7XG4gICAgICAgIGxldCBvcGVucyA9IGNoYXJDb3VudChyaHMsICQuT1BFTl9DSE9JQ0UpO1xuICAgICAgICBsZXQgY2xvc2VzID0gY2hhckNvdW50KHJocywgJC5DTE9TRV9DSE9JQ0UpO1xuICAgICAgICB3aGlsZSAob3BlbnMgPiBjbG9zZXMpIHtcbiAgICAgICAgICBsZXQgbGluZSA9IGxpbmVzWysraV07XG4gICAgICAgICAgcmhzICs9IFwiXFxuXCIgKyBsaW5lO1xuICAgICAgICAgIG9wZW5zICs9IGNoYXJDb3VudChsaW5lLCAkLk9QRU5fQ0hPSUNFKTtcbiAgICAgICAgICBjbG9zZXMgKz0gY2hhckNvdW50KGxpbmUsICQuQ0xPU0VfQ0hPSUNFKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJC5PUEVOX1NJTEVOVCArIChsaHMgKyBcIj1cIiArIHJocykgKyAkLkNMT1NFX1NJTEVOVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGggLSAxKVxuICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFJpUXVlcnkgb2JqZWN0IGZyb20gdGhlIHJhdyBxdWVyeSBzdHJpbmdcbiAgICogQHBhY2thZ2UgXG4gICAqL1xuICBjcmVhdGVRdWVyeShyYXdRdWVyeSwgb3B0cykge1xuICAgIHJldHVybiBuZXcgUmlRdWVyeSh0aGlzLCByYXdRdWVyeSwgb3B0cyk7XG4gIH1cbiAgLyoqIEBwcml2YXRlICovXG4gIF9wb3N0UGFyc2UoaW5wdXQsIG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgbGV0IGRlY29kZWQgPSBkZWNvZGUoaW5wdXQpO1xuICAgIGxldCByZXN1bHQgPSBkZWNvZGVkLnJlcGxhY2UodGhpcy5yZWdleC5XaGl0ZXNwYWNlLCBcIiBcIikucmVwbGFjZSh0aGlzLnJlZ2V4LkVuZGluZ0JyZWFrLCBcIlwiKTtcbiAgICBsZXQgZ2F0ZXMgPSBbLi4ucmVzdWx0Lm1hdGNoQWxsKHRoaXMucGVuZGluZ0dhdGVSZSldO1xuICAgIGlmIChvcHRzLnRyYWNlICYmIGdhdGVzLmxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coXCItXCIucmVwZWF0KDIwKSArIFwiIHBHYXRlcyBcIiArIFwiLVwiLnJlcGVhdCgyMCkpO1xuICAgIH1cbiAgICB0aGlzLnZpc2l0b3Iub3JkZXIgPSAwO1xuICAgIGdhdGVzLmZvckVhY2goKGcpID0+IHtcbiAgICAgIGlmICghZyB8fCAhZ1swXSB8fCAhZ1sxXSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJiYWQgZ2F0ZTogXCIgKyBnKTtcbiAgICAgIGxldCBkZWZlcnJlZEdhdGUgPSB0aGlzLnZpc2l0b3IucGVuZGluZ0dhdGVzW2dbMV1dO1xuICAgICAgaWYgKCFkZWZlcnJlZEdhdGUpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gZGVmZXJyZWRHYXRlOiBcIiArIGdbMV0pO1xuICAgICAgbGV0IHsgZGVmZXJyZWRDb250ZXh0LCBvcGVyYW5kcywgZ2F0ZVRleHQgfSA9IGRlZmVycmVkR2F0ZTtcbiAgICAgIGlmICghb3BlcmFuZHMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vIG9wZXJhbmRzXCIpO1xuICAgICAgbGV0IHJlamVjdCA9IHRoaXMudmlzaXRvci5jaG9pY2UoZGVmZXJyZWRDb250ZXh0LCB7IGZvcmNlUmVqZWN0OiB0cnVlIH0pO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoZ1swXSwgcmVqZWN0KTtcbiAgICAgIGlmIChvcHRzLnRyYWNlKVxuICAgICAgICBjb25zb2xlLmxvZyhcIlVucmVzb2x2ZWQgZ2F0ZTogJ1wiICsgZ2F0ZVRleHQgKyBcIicge3JlamVjdH1cIik7XG4gICAgfSk7XG4gICAgaWYgKG9wdHMudHJhY2UpXG4gICAgICBjb25zb2xlLmxvZyhgXG5GaW5hbDogJyR7cmVzdWx0fSdgKTtcbiAgICBpZiAoIW9wdHMucHJlc2VydmVMb29rdXBzKSB7XG4gICAgICB0aGlzLnZpc2l0b3Iuc3RhdGljcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMudmlzaXRvci5keW5hbWljcyA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUGFyc2VzIGEgbWluZ28gcXVlcnkgaW50byBKU09OIGZvcm1hdFxuICAgKiBAcGFja2FnZVxuICAgKi9cbiAgcGFyc2VKU09MKHRleHQpIHtcbiAgICBjb25zdCB1bmVzY2FwZVJlZ2V4UHJvcGVydHkgPSAodGV4dDIpID0+IHtcbiAgICAgIGNvbnN0IFJlZ2V4RXNjYXBlID0gVXRpbC5SZWdleEVzY2FwZTtcbiAgICAgIGxldCByZXMgPSB0ZXh0MjtcbiAgICAgIGlmICh0eXBlb2YgdGV4dDIgPT09IFwic3RyaW5nXCIgJiYgdGV4dDIuc3RhcnRzV2l0aChSZWdleEVzY2FwZSkgJiYgdGV4dDIuZW5kc1dpdGgoUmVnZXhFc2NhcGUpKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRleHQyLnNwbGl0KFJlZ2V4RXNjYXBlKTtcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gNClcbiAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgcmVnZXggaW4gdW5lc2NhcGVcIik7XG4gICAgICAgIHJlcyA9IG5ldyBSZWdFeHAocGFydHNbMV0sIHBhcnRzWzJdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBsZXQgZXNjYXBlZCA9IGVzY2FwZUpTT05SZWdleCh0ZXh0KS5yZXBsYWNlKHRoaXMucmVnZXguSlNPTElkZW50LCAnXCIkMVwiOicpLnJlcGxhY2UoLycvZywgJ1wiJyk7XG4gICAgbGV0IHJlc3VsdCA9IEpTT04ucGFyc2UoZXNjYXBlZCksIHVycCA9IHVuZXNjYXBlUmVnZXhQcm9wZXJ0eTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goKGspID0+IHJlc3VsdFtrXSA9IHVycChyZXN1bHRba10pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8qKlxuICAgKiBUcnVlIGlmIGlucHV0IGNvbnRhaW5zIHBhcnNlYWJsZSBzY3JpcHRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzUGFyc2VhYmxlKHMpIHtcbiAgICBsZXQgcmVzdWx0ID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmVzdWx0ID0gdGhpcy5yZWdleC5TcGVjaWFsLnRlc3QocykgfHwgcy5pbmNsdWRlcyh0aGlzLlN5bWJvbHMuUEVORElOR19HQVRFKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09IHN0YXRpY3MgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogRGVmYXVsdCB0cmFuc2Zvcm0gdGhhdCBwbHVyYWxpemVzIGEgc3RyaW5nICh1c2VzIFJpVGEgaWYgYXZhaWxhYmxlIGZvciBwaG9uZW1lcylcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSB0aGUgc3RyaW5nIHRvIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge29iamVjdH0gW3BsdXJhbGl6ZXJdIC0gY3VzdG9tIHBsdXJhbGl6ZXIgd2l0aCBwbHVyYWxpemUoKSBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdHJhbnNmb3JtZWQgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgcGx1cmFsaXplKHMsIHBsdXJhbGl6ZXIpIHtcbiAgICBpZiAoIXBsdXJhbGl6ZXI/LnBsdXJhbGl6ZSkge1xuICAgICAgaWYgKCFfUmlTY3JpcHQuUmlUYVdhcm5pbmdzLnBsdXJhbHMgJiYgIV9SaVNjcmlwdC5SaVRhV2FybmluZ3Muc2lsZW50KSB7XG4gICAgICAgIF9SaVNjcmlwdC5SaVRhV2FybmluZ3MucGx1cmFscyA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOXSBJbnN0YWxsIFJpVGEgZm9yIHByb3BlciBwbHVyYWxpemF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHMuZW5kc1dpdGgoXCJzXCIpID8gcyA6IHMgKyBcInNcIjtcbiAgICB9XG4gICAgcmV0dXJuIHBsdXJhbGl6ZXIucGx1cmFsaXplKHMpO1xuICB9XG4gIC8qKlxuICAgKiBEZWZhdWx0IHRyYW5zZm9ybSB0aGF0IGFkZHMgYW4gYXJ0aWNsZSAodXNlcyBSaVRhIGlmIGF2YWlsYWJsZSBmb3IgcGhvbmVtZXMpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gdGhlIHN0cmluZyB0byB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtvYmplY3R9IFtwaG9uZW1lQW5hbHl6ZXJdIC0gY3VzdG9tIHBob25lbWUgYW5hbHl6ZXIgd2l0aCBwaG9uZXMoKSBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdHJhbnNmb3JtZWQgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgYXJ0aWNsaXplKHMsIHBob25lbWVBbmFseXplcikge1xuICAgIGlmICghcyB8fCAhcy5sZW5ndGgpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBsZXQgZmlyc3QgPSBzLnNwbGl0KC9cXHMrLylbMF07XG4gICAgaWYgKCFwaG9uZW1lQW5hbHl6ZXI/LnBob25lcykge1xuICAgICAgaWYgKCFfUmlTY3JpcHQuUmlUYVdhcm5pbmdzLnBob25lcyAmJiAhX1JpU2NyaXB0LlJpVGFXYXJuaW5ncy5zaWxlbnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5dIEluc3RhbGwgUmlUYSBmb3IgcHJvcGVyIHBob25lbWVzXCIpO1xuICAgICAgICBfUmlTY3JpcHQuUmlUYVdhcm5pbmdzLnBob25lcyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKC9eW2FlaW91XS4qL2kudGVzdChmaXJzdCkgPyBcImFuIFwiIDogXCJhIFwiKSArIHM7XG4gICAgfVxuICAgIGxldCBwaG9uZXMgPSBwaG9uZW1lQW5hbHl6ZXIucGhvbmVzKGZpcnN0LCB7IHNpbGVudDogdHJ1ZSB9KTtcbiAgICByZXR1cm4gKHBob25lcz8ubGVuZ3RoICYmIFZvd2Vscy50ZXN0KHBob25lc1swXSkgPyBcImFuIFwiIDogXCJhIFwiKSArIHM7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgdHJhbnNmb3JtIHRoYXQgdXBwZXJjYXNlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSB0aGUgc3RyaW5nIHRvIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdHJhbnNmb3JtZWQgc3RyaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgY2FwaXRhbGl6ZShzKSB7XG4gICAgcmV0dXJuIHMgPyBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnN1YnN0cmluZygxKSA6IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgdHJhbnNmb3JtIHRoYXQgY2FwaXRhbGl6ZXMgdGhlIHN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0cmFuc2Zvcm1lZCBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyB1cHBlcmNhc2Uocykge1xuICAgIHJldHVybiBzID8gcy50b1VwcGVyQ2FzZSgpIDogXCJcIjtcbiAgfVxuICAvKipcbiAgICogRGVmYXVsdCB0cmFuc2Zvcm0gdGhhdCB3cmFwcyB0aGUgc3RyaW5nIGluIChzbWFydCkgcXVvdGVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0cmFuc2Zvcm1lZCBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBxdW90aWZ5KHMpIHtcbiAgICByZXR1cm4gXCImIzgyMjA7XCIgKyAocyB8fCBcIlwiKSArIFwiJiM4MjIxO1wiO1xuICB9XG4gIC8qKlxuICAgKiBEZWZhdWx0IG5vLW9wIHRyYW5zZm9ybVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyAtIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB0cmFuc2Zvcm1lZCBzdHJpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBpZGVudGl0eShzKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PSBoZWxwZXJzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLyoqIEBwcml2YXRlICovXG4gIF9jcmVhdGVSZWdleGVzKHRva2Vucykge1xuICAgIGNvbnN0IEVzYyA9IHRoaXMuRXNjYXBlZDtcbiAgICBjb25zdCBvcGVuID0gRXNjLk9QRU5fQ0hPSUNFO1xuICAgIGNvbnN0IGNsb3NlID0gRXNjLkNMT1NFX0NIT0lDRTtcbiAgICBjb25zdCBhbnlzeW0gPSBFc2MuU1RBVElDICsgRXNjLkRZTkFNSUM7XG4gICAgcmV0dXJuIHtcbiAgICAgIExpbmVCcmVha3M6IC9cXHI/XFxuLyxcbiAgICAgIEVuZGluZ0JyZWFrOiAvXFxyP1xcbiQvLFxuICAgICAgTm9uR2F0ZUF0U2lnbnM6IC8oW159XSlAKD8heykvLFxuICAgICAgQW55U3ltYm9sOiBuZXcgUmVnRXhwKGBbJHthbnlzeW19XWApLFxuICAgICAgUGFyZW50aGVzaXplZFdlaWdodHM6IC9cXChcXHMqKFxcZCspXFxzKlxcKS9nLFxuICAgICAgLy8gVE9ETzogY2hhbmdlIGZvciBuZWdhdGl2ZSB3ZWlnaHRzXG4gICAgICBNdWx0aUxpbmVDb21tZW50czogL1xcL1xcKlteXSo/KFxccj9cXG4pP1xcLy9nLFxuICAgICAgU2luZ2xlTGluZUNvbW1lbnRzOiAvXFwvXFwvW15cXG5dKyhcXHI/XFxufCQpL2csXG4gICAgICBNYXJrZG93bkxpbmtzOiAvXFxbKFteXFxdXSspXFxdXFwoKFteKVwiXSspKD86IFxcXCIoW15cXFwiXSspXFxcIik/XFwpL2csXG4gICAgICBSYXdBc3NpZ246IG5ldyBSZWdFeHAoYF5bJHthbnlzeW19XVtBLVphLXpfMC05XVtBLVphLXpfMC05XSpcXFxccyo9YCksXG4gICAgICBKU09MSWRlbnQ6IG5ldyBSZWdFeHAoYChbJHthbnlzeW19XT9bQS1aYS16XzAtOV1bQS1aYS16XzAtOV0qKVxcXFxzKjpgLCBcImdcIiksXG4gICAgICBDaG9pY2VXcmFwOiBuZXcgUmVnRXhwKFwiXlwiICsgb3BlbiArIFwiW15cIiArIG9wZW4gKyBjbG9zZSArIFwiXSpcIiArIGNsb3NlICsgXCIkXCIpLFxuICAgICAgVmFsaWRTeW1ib2w6IG5ldyBSZWdFeHAoXCIoXCIgKyBFc2MuRFlOQU1JQyArIFwifFwiICsgRXNjLlNUQVRJQyArIFwiW0EtWmEtel8wLTldKVtBLVphLXpfMC05XSpcIiksXG4gICAgICBFbnRpdHk6IHRva2Vucy5maWx0ZXIoKHQpID0+IHQubmFtZSA9PT0gXCJFbnRpdHlcIilbMF0uUEFUVEVSTixcbiAgICAgIFN0YXRpY1N5bWJvbDogbmV3IFJlZ0V4cChFc2MuU1RBVElDICsgXCJbQS1aYS16XzAtOV1bQS1aYS16XzAtOV0qXCIpLFxuICAgICAgU3BlY2lhbDogbmV3IFJlZ0V4cChgWyR7RXNjLlNQRUNJQUwucmVwbGFjZShcIiZcIiwgXCJcIil9XWApLFxuICAgICAgQ29udGludWU6IG5ldyBSZWdFeHAoRXNjLkNPTlRJTlVBVElPTiArIFwiXFxcXHI/XFxcXG5cIiwgXCJnXCIpLFxuICAgICAgV2hpdGVzcGFjZTogL1tcXHUwMGEwXFx1MjAwMC1cXHUyMDBiXFx1MjAyOC1cXHUyMDI5XFx1MzAwMF0rL2dcbiAgICB9O1xuICB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBfY3JlYXRlVHJhbnNmb3JtcygpIHtcbiAgICBsZXQgdHJhbnNmb3JtcyA9IHtcbiAgICAgIHF1b3RpZnk6ICh3KSA9PiBfUmlTY3JpcHQucXVvdGlmeSh3KSxcbiAgICAgIHBsdXJhbGl6ZTogKHcpID0+IF9SaVNjcmlwdC5wbHVyYWxpemUodywgdGhpcy5SaVRhKSxcbiAgICAgIGFydGljbGl6ZTogKHcpID0+IF9SaVNjcmlwdC5hcnRpY2xpemUodywgdGhpcy5SaVRhKSxcbiAgICAgIGNhcGl0YWxpemU6ICh3KSA9PiBfUmlTY3JpcHQuY2FwaXRhbGl6ZSh3KSxcbiAgICAgIHVwcGVyY2FzZTogKHcpID0+IF9SaVNjcmlwdC51cHBlcmNhc2UodyksXG4gICAgICBub3JlcGVhdDogKHcpID0+IF9SaVNjcmlwdC5pZGVudGl0eSh3KVxuICAgIH07XG4gICAgdHJhbnNmb3Jtcy5hcnQgPSB0cmFuc2Zvcm1zLmFydGljbGl6ZTtcbiAgICB0cmFuc2Zvcm1zLm5yID0gdHJhbnNmb3Jtcy5ub3JlcGVhdDtcbiAgICB0cmFuc2Zvcm1zLmNhcCA9IHRyYW5zZm9ybXMuY2FwaXRhbGl6ZTtcbiAgICB0cmFuc2Zvcm1zLnVjID0gdHJhbnNmb3Jtcy51cHBlcmNhc2U7XG4gICAgdHJhbnNmb3Jtcy5xcSA9IHRyYW5zZm9ybXMucXVvdGlmeTtcbiAgICB0cmFuc2Zvcm1zLnMgPSB0cmFuc2Zvcm1zLnBsdXJhbGl6ZTtcbiAgICB0cmFuc2Zvcm1zLnVjZiA9IHRyYW5zZm9ybXMuY2FwaXRhbGl6ZTtcbiAgICByZXR1cm4gdHJhbnNmb3JtcztcbiAgfVxufTtcbi8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuX19wdWJsaWNGaWVsZChfUmlTY3JpcHQsIFwiVkVSU0lPTlwiLCBcIjEuMS4xXCIpO1xuLyoqIEB0eXBlIHt0eXBlb2YgUmlRdWVyeX0gKi9cbl9fcHVibGljRmllbGQoX1JpU2NyaXB0LCBcIlF1ZXJ5XCIsIFJpUXVlcnkpO1xuLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgYm9vbGVhbj59ICovXG5fX3B1YmxpY0ZpZWxkKF9SaVNjcmlwdCwgXCJSaVRhV2FybmluZ3NcIiwgeyBwbHVyYWxzOiBmYWxzZSwgcGhvbmVzOiBmYWxzZSwgc2lsZW50OiBmYWxzZSB9KTtcbnZhciBSaVNjcmlwdCA9IF9SaVNjcmlwdDtcbmZ1bmN0aW9uIGNoYXJDb3VudChzdHIsIGMpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSBjKVxuICAgICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5SaVNjcmlwdC5WaXNpdG9yID0gUmlTY3JpcHRWaXNpdG9yO1xuUmlTY3JpcHQuVXRpbCA9IFV0aWw7XG5leHBvcnQge1xuICBSaUdyYW1tYXIsXG4gIFJpU2NyaXB0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlzY3JpcHQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/riscript/dist/riscript.js\n");

/***/ })

};
;